{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\cache\\rowNodeCache.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\cache\\rowNodeCache.js","mtime":1525243700093},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\r\n * @version v17.1.1\r\n * @link http://www.ag-grid.com/\r\n * @license MIT\r\n */\r\n\"use strict\";\r\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = require(\"../../utils\");\r\nvar beanStub_1 = require(\"../../context/beanStub\");\r\nvar rowNodeBlock_1 = require(\"./rowNodeBlock\");\r\nvar RowNodeCache = /*@__PURE__*/ (function (_super) {\r\n    __extends(RowNodeCache, _super);\r\n    function RowNodeCache(cacheParams) {\r\n        var _this = _super.call(this) || this;\r\n        _this.maxRowFound = false;\r\n        _this.blocks = {};\r\n        _this.blockCount = 0;\r\n        _this.virtualRowCount = cacheParams.initialRowCount;\r\n        _this.cacheParams = cacheParams;\r\n        return _this;\r\n    }\r\n    RowNodeCache.prototype.destroy = function () {\r\n        var _this = this;\r\n        _super.prototype.destroy.call(this);\r\n        this.forEachBlockInOrder(function (block) { return _this.destroyBlock(block); });\r\n    };\r\n    RowNodeCache.prototype.init = function () {\r\n        var _this = this;\r\n        this.active = true;\r\n        this.addDestroyFunc(function () { return _this.active = false; });\r\n    };\r\n    RowNodeCache.prototype.isActive = function () {\r\n        return this.active;\r\n    };\r\n    RowNodeCache.prototype.getVirtualRowCount = function () {\r\n        return this.virtualRowCount;\r\n    };\r\n    RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {\r\n        this.virtualRowCount = virtualRowCount;\r\n    };\r\n    RowNodeCache.prototype.isMaxRowFound = function () {\r\n        return this.maxRowFound;\r\n    };\r\n    // listener on EVENT_LOAD_COMPLETE\r\n    RowNodeCache.prototype.onPageLoaded = function (event) {\r\n        this.cacheParams.rowNodeBlockLoader.loadComplete();\r\n        this.checkBlockToLoad();\r\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\r\n        // grid to refresh even though we are no longer the active cache\r\n        if (!this.isActive()) {\r\n            return;\r\n        }\r\n        this.logger.log(\"onPageLoaded: page = \" + event.page.getBlockNumber() + \", lastRow = \" + event.lastRow);\r\n        if (event.success) {\r\n            this.checkVirtualRowCount(event.page, event.lastRow);\r\n        }\r\n    };\r\n    RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\r\n        var _this = this;\r\n        // no purge if user didn't give maxBlocksInCache\r\n        if (utils_1.Utils.missing(this.cacheParams.maxBlocksInCache)) {\r\n            return;\r\n        }\r\n        // no purge if block count is less than max allowed\r\n        if (this.blockCount <= this.cacheParams.maxBlocksInCache) {\r\n            return;\r\n        }\r\n        // put all candidate blocks into a list for sorting\r\n        var blocksForPurging = [];\r\n        this.forEachBlockInOrder(function (block) {\r\n            // we exclude checking for the page just created, as this has yet to be accessed and hence\r\n            // the lastAccessed stamp will not be updated for the first time yet\r\n            if (block === blockToExclude) {\r\n                return;\r\n            }\r\n            blocksForPurging.push(block);\r\n        });\r\n        // todo: need to verify that this sorts items in the right order\r\n        blocksForPurging.sort(function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); });\r\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\r\n        // in other words, after the splice operation below, we have taken out the blocks\r\n        // we want to keep, which means we are left with blocks that we can potentially purge\r\n        var blocksToKeep = this.cacheParams.maxBlocksInCache - 1;\r\n        blocksForPurging.splice(0, blocksToKeep);\r\n        // try and purge each block\r\n        blocksForPurging.forEach(function (block) {\r\n            // we never purge blocks if they are open, as purging them would mess up with\r\n            // our indexes, it would be very messy to restore the purged block to it's\r\n            // previous state if it had open children (and what if open children of open\r\n            // children, jeeeesus, just thinking about it freaks me out) so best is have a\r\n            // rule, if block is open, we never purge.\r\n            if (block.isAnyNodeOpen(_this.virtualRowCount)) {\r\n                return;\r\n            }\r\n            // at this point, block is not needed, and no open nodes, so burn baby burn\r\n            _this.removeBlockFromCache(block);\r\n        });\r\n    };\r\n    RowNodeCache.prototype.postCreateBlock = function (newBlock) {\r\n        newBlock.addEventListener(rowNodeBlock_1.RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\r\n        this.setBlock(newBlock.getBlockNumber(), newBlock);\r\n        this.purgeBlocksIfNeeded(newBlock);\r\n        this.checkBlockToLoad();\r\n    };\r\n    RowNodeCache.prototype.removeBlockFromCache = function (blockToRemove) {\r\n        if (!blockToRemove) {\r\n            return;\r\n        }\r\n        this.destroyBlock(blockToRemove);\r\n        // we do not want to remove the 'loaded' event listener, as the\r\n        // concurrent loads count needs to be updated when the load is complete\r\n        // if the purged page is in loading state\r\n    };\r\n    // gets called after: 1) block loaded 2) block created 3) cache refresh\r\n    RowNodeCache.prototype.checkBlockToLoad = function () {\r\n        this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\r\n    };\r\n    RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {\r\n        // if client provided a last row, we always use it, as it could change between server calls\r\n        // if user deleted data and then called refresh on the grid.\r\n        if (typeof lastRow === 'number' && lastRow >= 0) {\r\n            this.virtualRowCount = lastRow;\r\n            this.maxRowFound = true;\r\n            this.onCacheUpdated();\r\n        }\r\n        else if (!this.maxRowFound) {\r\n            // otherwise, see if we need to add some virtual rows\r\n            var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\r\n            var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\r\n            if (this.virtualRowCount < lastRowIndexPlusOverflow) {\r\n                this.virtualRowCount = lastRowIndexPlusOverflow;\r\n                this.onCacheUpdated();\r\n            }\r\n            else if (this.cacheParams.dynamicRowHeight) {\r\n                // the only other time is if dynamic row height, as loading rows\r\n                // will change the height of the block, given the height of the rows\r\n                // is only known after the row is loaded.\r\n                this.onCacheUpdated();\r\n            }\r\n        }\r\n    };\r\n    RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\r\n        this.virtualRowCount = rowCount;\r\n        // if undefined is passed, we do not set this value, if one of {true,false}\r\n        // is passed, we do set the value.\r\n        if (utils_1.Utils.exists(maxRowFound)) {\r\n            this.maxRowFound = maxRowFound;\r\n        }\r\n        // if we are still searching, then the row count must not end at the end\r\n        // of a particular page, otherwise the searching will not pop into the\r\n        // next page\r\n        if (!this.maxRowFound) {\r\n            if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\r\n                this.virtualRowCount++;\r\n            }\r\n        }\r\n        this.onCacheUpdated();\r\n    };\r\n    RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {\r\n        var _this = this;\r\n        this.forEachBlockInOrder(function (block) {\r\n            block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);\r\n        });\r\n    };\r\n    RowNodeCache.prototype.forEachBlockInOrder = function (callback) {\r\n        var ids = this.getBlockIdsSorted();\r\n        this.forEachBlockId(ids, callback);\r\n    };\r\n    RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {\r\n        var ids = this.getBlockIdsSorted().reverse();\r\n        this.forEachBlockId(ids, callback);\r\n    };\r\n    RowNodeCache.prototype.forEachBlockId = function (ids, callback) {\r\n        var _this = this;\r\n        ids.forEach(function (id) {\r\n            var block = _this.blocks[id];\r\n            callback(block, id);\r\n        });\r\n    };\r\n    RowNodeCache.prototype.getBlockIdsSorted = function () {\r\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\r\n        var numberComparator = function (a, b) { return a - b; }; // default comparator for array is string comparison\r\n        var blockIds = Object.keys(this.blocks).map(function (idStr) { return parseInt(idStr); }).sort(numberComparator);\r\n        return blockIds;\r\n    };\r\n    RowNodeCache.prototype.getBlock = function (blockId) {\r\n        return this.blocks[blockId];\r\n    };\r\n    RowNodeCache.prototype.setBlock = function (id, block) {\r\n        this.blocks[id] = block;\r\n        this.blockCount++;\r\n        this.cacheParams.rowNodeBlockLoader.addBlock(block);\r\n    };\r\n    RowNodeCache.prototype.destroyBlock = function (block) {\r\n        delete this.blocks[block.getBlockNumber()];\r\n        block.destroy();\r\n        this.blockCount--;\r\n        this.cacheParams.rowNodeBlockLoader.removeBlock(block);\r\n    };\r\n    // gets called 1) row count changed 2) cache purged 3) items inserted\r\n    RowNodeCache.prototype.onCacheUpdated = function () {\r\n        if (this.isActive()) {\r\n            // this results in both row models (infinite and enterprise) firing ModelUpdated,\r\n            // however enterprise also updates the row indexes first\r\n            var event_1 = {\r\n                type: RowNodeCache.EVENT_CACHE_UPDATED\r\n            };\r\n            this.dispatchEvent(event_1);\r\n        }\r\n    };\r\n    RowNodeCache.prototype.purgeCache = function () {\r\n        var _this = this;\r\n        this.forEachBlockInOrder(function (block) { return _this.removeBlockFromCache(block); });\r\n        this.onCacheUpdated();\r\n    };\r\n    RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\r\n        var _this = this;\r\n        var result = [];\r\n        var lastBlockId = -1;\r\n        var inActiveRange = false;\r\n        var numberSequence = new utils_1.NumberSequence();\r\n        // if only one node passed, we start the selection at the top\r\n        if (utils_1.Utils.missing(firstInRange)) {\r\n            inActiveRange = true;\r\n        }\r\n        var foundGapInSelection = false;\r\n        this.forEachBlockInOrder(function (block, id) {\r\n            if (foundGapInSelection)\r\n                return;\r\n            if (inActiveRange && (lastBlockId + 1 !== id)) {\r\n                foundGapInSelection = true;\r\n                return;\r\n            }\r\n            lastBlockId = id;\r\n            block.forEachNodeShallow(function (rowNode) {\r\n                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\r\n                if (inActiveRange || hitFirstOrLast) {\r\n                    result.push(rowNode);\r\n                }\r\n                if (hitFirstOrLast) {\r\n                    inActiveRange = !inActiveRange;\r\n                }\r\n            }, numberSequence, _this.virtualRowCount);\r\n        });\r\n        // inActiveRange will be still true if we never hit the second rowNode\r\n        var invalidRange = foundGapInSelection || inActiveRange;\r\n        return invalidRange ? [] : result;\r\n    };\r\n    RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated';\r\n    return RowNodeCache;\r\n}(beanStub_1.BeanStub));\r\nexports.RowNodeCache = RowNodeCache;\r\n",null]}