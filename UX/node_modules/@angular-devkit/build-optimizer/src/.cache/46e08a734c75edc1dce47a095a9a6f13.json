{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\cache\\rowNodeBlock.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\cache\\rowNodeBlock.js","mtime":1525243700079},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\r\n * @version v17.1.1\r\n * @link http://www.ag-grid.com/\r\n * @license MIT\r\n */\r\n\"use strict\";\r\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = require(\"../../utils\");\r\nvar rowNode_1 = require(\"../../entities/rowNode\");\r\nvar beanStub_1 = require(\"../../context/beanStub\");\r\nvar RowNodeBlock = /*@__PURE__*/ (function (_super) {\r\n    __extends(RowNodeBlock, _super);\r\n    function RowNodeBlock(blockNumber, rowNodeCacheParams) {\r\n        var _this = _super.call(this) || this;\r\n        _this.version = 0;\r\n        _this.state = RowNodeBlock.STATE_DIRTY;\r\n        _this.rowNodeCacheParams = rowNodeCacheParams;\r\n        _this.blockNumber = blockNumber;\r\n        // we don't need to calculate these now, as the inputs don't change,\r\n        // however it makes the code easier to read if we work them out up front\r\n        _this.startRow = blockNumber * rowNodeCacheParams.blockSize;\r\n        _this.endRow = _this.startRow + rowNodeCacheParams.blockSize;\r\n        return _this;\r\n    }\r\n    RowNodeBlock.prototype.isAnyNodeOpen = function (rowCount) {\r\n        var result = false;\r\n        this.forEachNodeCallback(function (rowNode) {\r\n            if (rowNode.expanded) {\r\n                result = true;\r\n            }\r\n        }, rowCount);\r\n        return result;\r\n    };\r\n    RowNodeBlock.prototype.forEachNodeCallback = function (callback, rowCount) {\r\n        for (var rowIndex = this.startRow; rowIndex < this.endRow; rowIndex++) {\r\n            // we check against rowCount as this page may be the last one, and if it is, then\r\n            // the last rows are not part of the set\r\n            if (rowIndex < rowCount) {\r\n                var rowNode = this.getRowUsingLocalIndex(rowIndex);\r\n                callback(rowNode, rowIndex);\r\n            }\r\n        }\r\n    };\r\n    RowNodeBlock.prototype.forEachNode = function (callback, sequence, rowCount, deep) {\r\n        this.forEachNodeCallback(function (rowNode) {\r\n            callback(rowNode, sequence.next());\r\n            // this will only every happen for enterprise row model, as infinite\r\n            // row model doesn't have groups\r\n            if (deep && rowNode.childrenCache) {\r\n                rowNode.childrenCache.forEachNodeDeep(callback, sequence);\r\n            }\r\n        }, rowCount);\r\n    };\r\n    RowNodeBlock.prototype.forEachNodeDeep = function (callback, sequence, rowCount) {\r\n        this.forEachNode(callback, sequence, rowCount, true);\r\n    };\r\n    RowNodeBlock.prototype.forEachNodeShallow = function (callback, sequence, rowCount) {\r\n        this.forEachNode(callback, sequence, rowCount, false);\r\n    };\r\n    RowNodeBlock.prototype.getVersion = function () {\r\n        return this.version;\r\n    };\r\n    RowNodeBlock.prototype.getLastAccessed = function () {\r\n        return this.lastAccessed;\r\n    };\r\n    RowNodeBlock.prototype.getRowUsingLocalIndex = function (rowIndex) {\r\n        this.lastAccessed = this.rowNodeCacheParams.lastAccessedSequence.next();\r\n        var localIndex = rowIndex - this.startRow;\r\n        return this.rowNodes[localIndex];\r\n    };\r\n    RowNodeBlock.prototype.init = function (beans) {\r\n        this.beans = beans;\r\n        this.createRowNodes();\r\n    };\r\n    RowNodeBlock.prototype.getStartRow = function () {\r\n        return this.startRow;\r\n    };\r\n    RowNodeBlock.prototype.getEndRow = function () {\r\n        return this.endRow;\r\n    };\r\n    RowNodeBlock.prototype.getBlockNumber = function () {\r\n        return this.blockNumber;\r\n    };\r\n    RowNodeBlock.prototype.setDirty = function () {\r\n        // in case any current loads in progress, this will have their results ignored\r\n        this.version++;\r\n        this.state = RowNodeBlock.STATE_DIRTY;\r\n    };\r\n    RowNodeBlock.prototype.setDirtyAndPurge = function () {\r\n        this.setDirty();\r\n        this.rowNodes.forEach(function (rowNode) {\r\n            rowNode.setData(null);\r\n        });\r\n    };\r\n    RowNodeBlock.prototype.getState = function () {\r\n        return this.state;\r\n    };\r\n    RowNodeBlock.prototype.setRowNode = function (rowIndex, rowNode) {\r\n        var localIndex = rowIndex - this.startRow;\r\n        this.rowNodes[localIndex] = rowNode;\r\n    };\r\n    RowNodeBlock.prototype.setBlankRowNode = function (rowIndex) {\r\n        var localIndex = rowIndex - this.startRow;\r\n        var newRowNode = this.createBlankRowNode(rowIndex);\r\n        this.rowNodes[localIndex] = newRowNode;\r\n        return newRowNode;\r\n    };\r\n    RowNodeBlock.prototype.setNewData = function (rowIndex, dataItem) {\r\n        var newRowNode = this.setBlankRowNode(rowIndex);\r\n        this.setDataAndId(newRowNode, dataItem, this.startRow + rowIndex);\r\n        return newRowNode;\r\n    };\r\n    RowNodeBlock.prototype.createBlankRowNode = function (rowIndex) {\r\n        var rowNode = new rowNode_1.RowNode();\r\n        this.beans.context.wireBean(rowNode);\r\n        rowNode.setRowHeight(this.rowNodeCacheParams.rowHeight);\r\n        return rowNode;\r\n    };\r\n    // creates empty row nodes, data is missing as not loaded yet\r\n    RowNodeBlock.prototype.createRowNodes = function () {\r\n        this.rowNodes = [];\r\n        for (var i = 0; i < this.rowNodeCacheParams.blockSize; i++) {\r\n            var rowIndex = this.startRow + i;\r\n            var rowNode = this.createBlankRowNode(rowIndex);\r\n            this.rowNodes.push(rowNode);\r\n        }\r\n    };\r\n    RowNodeBlock.prototype.load = function () {\r\n        this.state = RowNodeBlock.STATE_LOADING;\r\n        this.loadFromDatasource();\r\n    };\r\n    RowNodeBlock.prototype.pageLoadFailed = function () {\r\n        this.state = RowNodeBlock.STATE_FAILED;\r\n        var event = {\r\n            type: RowNodeBlock.EVENT_LOAD_COMPLETE,\r\n            success: false,\r\n            page: this,\r\n            lastRow: null\r\n        };\r\n        this.dispatchEvent(event);\r\n    };\r\n    RowNodeBlock.prototype.populateWithRowData = function (rows) {\r\n        var _this = this;\r\n        var rowNodesToRefresh = [];\r\n        this.rowNodes.forEach(function (rowNode, index) {\r\n            var data = rows[index];\r\n            if (rowNode.stub) {\r\n                rowNodesToRefresh.push(rowNode);\r\n            }\r\n            _this.setDataAndId(rowNode, data, _this.startRow + index);\r\n        });\r\n        if (rowNodesToRefresh.length > 0) {\r\n            this.beans.rowRenderer.redrawRows(rowNodesToRefresh);\r\n        }\r\n    };\r\n    RowNodeBlock.prototype.destroy = function () {\r\n        _super.prototype.destroy.call(this);\r\n        this.rowNodes.forEach(function (rowNode) {\r\n            if (rowNode.childrenCache) {\r\n                rowNode.childrenCache.destroy();\r\n                rowNode.childrenCache = null;\r\n            }\r\n            // this is needed, so row render knows to fade out the row, otherwise it\r\n            // see's row top is present, and thinks the row should be shown. maybe\r\n            // rowNode should have a flag on whether it is visible???\r\n            rowNode.clearRowTop();\r\n        });\r\n    };\r\n    RowNodeBlock.prototype.pageLoaded = function (version, rows, lastRow) {\r\n        // we need to check the version, in case there was an old request\r\n        // from the server that was sent before we refreshed the cache,\r\n        // if the load was done as a result of a cache refresh\r\n        if (version === this.version) {\r\n            this.state = RowNodeBlock.STATE_LOADED;\r\n            this.populateWithRowData(rows);\r\n        }\r\n        lastRow = utils_1.Utils.cleanNumber(lastRow);\r\n        // check here if lastrow should be set\r\n        var event = {\r\n            type: RowNodeBlock.EVENT_LOAD_COMPLETE,\r\n            success: true,\r\n            page: this,\r\n            lastRow: lastRow\r\n        };\r\n        this.dispatchEvent(event);\r\n    };\r\n    RowNodeBlock.EVENT_LOAD_COMPLETE = 'loadComplete';\r\n    RowNodeBlock.STATE_DIRTY = 'dirty';\r\n    RowNodeBlock.STATE_LOADING = 'loading';\r\n    RowNodeBlock.STATE_LOADED = 'loaded';\r\n    RowNodeBlock.STATE_FAILED = 'failed';\r\n    return RowNodeBlock;\r\n}(beanStub_1.BeanStub));\r\nexports.RowNodeBlock = RowNodeBlock;\r\n",null]}