{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rendering\\cellComp.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rendering\\cellComp.js","mtime":1525243699687},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\r\n * @version v17.1.1\r\n * @link http://www.ag-grid.com/\r\n * @license MIT\r\n */\r\n\"use strict\";\r\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = require(\"../utils\");\r\nvar column_1 = require(\"../entities/column\");\r\nvar rowNode_1 = require(\"../entities/rowNode\");\r\nvar constants_1 = require(\"../constants\");\r\nvar events_1 = require(\"../events\");\r\nvar gridCell_1 = require(\"../entities/gridCell\");\r\nvar component_1 = require(\"../widgets/component\");\r\nvar checkboxSelectionComponent_1 = require(\"./checkboxSelectionComponent\");\r\nvar rowDragComp_1 = require(\"./rowDragComp\");\r\nvar CellComp = /*@__PURE__*/ (function (_super) {\r\n    __extends(CellComp, _super);\r\n    function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell) {\r\n        var _this = _super.call(this) || this;\r\n        _this.editingCell = false;\r\n        // every time we go into edit mode, or back again, this gets incremented.\r\n        // it's the components way of dealing with the async nature of framework components,\r\n        // so if a framework component takes a while to be created, we know if the object\r\n        // is still relevant when creating is finished. eg we could click edit / unedit 20\r\n        // times before the first React edit component comes back - we should discard\r\n        // the first 19.\r\n        _this.cellEditorVersion = 0;\r\n        _this.cellRendererVersion = 0;\r\n        _this.scope = scope;\r\n        _this.beans = beans;\r\n        _this.column = column;\r\n        _this.rowNode = rowNode;\r\n        _this.rowComp = rowComp;\r\n        _this.autoHeightCell = autoHeightCell;\r\n        _this.createGridCellVo();\r\n        _this.rangeSelectionEnabled = beans.enterprise && beans.gridOptionsWrapper.isEnableRangeSelection();\r\n        _this.cellFocused = _this.beans.focusedCellController.isCellFocused(_this.gridCell);\r\n        _this.firstRightPinned = _this.column.isFirstRightPinned();\r\n        _this.lastLeftPinned = _this.column.isLastLeftPinned();\r\n        if (_this.rangeSelectionEnabled) {\r\n            _this.rangeCount = _this.beans.rangeController.getCellRangeCount(_this.gridCell);\r\n        }\r\n        _this.getValueAndFormat();\r\n        _this.setUsingWrapper();\r\n        _this.chooseCellRenderer();\r\n        _this.setupColSpan();\r\n        return _this;\r\n    }\r\n    CellComp.prototype.getCreateTemplate = function () {\r\n        var templateParts = [];\r\n        var col = this.column;\r\n        var width = this.getCellWidth();\r\n        var left = col.getLeft();\r\n        var valueToRender = this.getInitialValueToRender();\r\n        var valueSanitised = utils_1._.get(this.column, 'colDef.template', null) ? valueToRender : utils_1._.escape(valueToRender);\r\n        this.tooltip = this.getToolTip();\r\n        var tooltipSanitised = utils_1._.escape(this.tooltip);\r\n        var colIdSanitised = utils_1._.escape(col.getId());\r\n        var wrapperStartTemplate;\r\n        var wrapperEndTemplate;\r\n        var stylesFromColDef = this.preProcessStylesFromColDef();\r\n        var cssClasses = this.getInitialCssClasses();\r\n        if (this.usingWrapper) {\r\n            wrapperStartTemplate = '<span ref=\"eCellWrapper\" class=\"ag-cell-wrapper\"><span ref=\"eCellValue\" class=\"ag-cell-value\">';\r\n            wrapperEndTemplate = '</span></span>';\r\n        }\r\n        // hey, this looks like React!!!\r\n        templateParts.push(\"<div\");\r\n        templateParts.push(\" tabindex=\\\"-1\\\"\");\r\n        templateParts.push(\" role=\\\"gridcell\\\"\");\r\n        templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\r\n        templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\r\n        templateParts.push(\" class=\\\"\" + cssClasses.join(' ') + \"\\\"\");\r\n        templateParts.push(tooltipSanitised ? \" title=\\\"\" + tooltipSanitised + \"\\\"\" : \"\");\r\n        templateParts.push(\" style=\\\"width: \" + width + \"px; left: \" + left + \"px; \" + stylesFromColDef + \"\\\" >\");\r\n        templateParts.push(wrapperStartTemplate);\r\n        templateParts.push(valueSanitised);\r\n        templateParts.push(wrapperEndTemplate);\r\n        templateParts.push(\"</div>\");\r\n        return templateParts.join('');\r\n    };\r\n    CellComp.prototype.afterAttached = function () {\r\n        var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\r\n        var eGui = this.eParentRow.querySelector(querySelector);\r\n        this.setGui(eGui);\r\n        // all of these have dependencies on the eGui, so only do them after eGui is set\r\n        this.addDomData();\r\n        this.populateTemplate();\r\n        this.attachCellRenderer();\r\n        this.angular1Compile();\r\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_CELL_FOCUSED, this.onCellFocused.bind(this));\r\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_FLASH_CELLS, this.onFlashCells.bind(this));\r\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, this.onColumnHover.bind(this));\r\n        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));\r\n        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_CELL_CHANGED, this.onCellChanged.bind(this));\r\n        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));\r\n        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onWidthChanged.bind(this));\r\n        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, this.onFirstRightPinnedChanged.bind(this));\r\n        this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, this.onLastLeftPinnedChanged.bind(this));\r\n        // if not doing enterprise, then range selection service would be missing\r\n        // so need to check before trying to use it\r\n        if (this.rangeSelectionEnabled) {\r\n            this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));\r\n        }\r\n    };\r\n    CellComp.prototype.onColumnHover = function () {\r\n        var isHovered = this.beans.columnHoverService.isHovered(this.column);\r\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\r\n    };\r\n    CellComp.prototype.onCellChanged = function (event) {\r\n        var eventImpactsThisCell = event.column === this.column;\r\n        if (eventImpactsThisCell) {\r\n            this.refreshCell({});\r\n        }\r\n    };\r\n    CellComp.prototype.getCellLeft = function () {\r\n        var mostLeftCol;\r\n        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\r\n            mostLeftCol = this.colsSpanning[this.colsSpanning.length - 1];\r\n        }\r\n        else {\r\n            mostLeftCol = this.column;\r\n        }\r\n        return mostLeftCol.getLeft();\r\n    };\r\n    CellComp.prototype.getCellWidth = function () {\r\n        if (this.colsSpanning) {\r\n            var result_1 = 0;\r\n            this.colsSpanning.forEach(function (col) { return result_1 += col.getActualWidth(); });\r\n            return result_1;\r\n        }\r\n        else {\r\n            return this.column.getActualWidth();\r\n        }\r\n    };\r\n    CellComp.prototype.onFlashCells = function (event) {\r\n        var cellId = this.gridCell.createId();\r\n        var shouldFlash = event.cells[cellId];\r\n        if (shouldFlash) {\r\n            this.animateCell('highlight');\r\n        }\r\n    };\r\n    CellComp.prototype.setupColSpan = function () {\r\n        // if no col span is active, then we don't set it up, as it would be wasteful of CPU\r\n        if (utils_1._.missing(this.column.getColDef().colSpan)) {\r\n            return;\r\n        }\r\n        // because we are col spanning, a reorder of the cols can change what cols we are spanning over\r\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));\r\n        // because we are spanning over multiple cols, we check for width any time any cols width changes.\r\n        // this is expensive - really we should be explicitly checking only the cols we are spanning over\r\n        // instead of every col, however it would be tricky code to track the cols we are spanning over, so\r\n        // because hardly anyone will be using colSpan, am favoring this easier way for more maintainable code.\r\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\r\n        this.colsSpanning = this.getColSpanningList();\r\n    };\r\n    CellComp.prototype.getColSpanningList = function () {\r\n        var colSpan = this.column.getColSpan(this.rowNode);\r\n        var colsSpanning = [];\r\n        // if just one col, the col span is just the column we are in\r\n        if (colSpan === 1) {\r\n            colsSpanning.push(this.column);\r\n        }\r\n        else {\r\n            var pointer = this.column;\r\n            var pinned = this.column.getPinned();\r\n            for (var i = 0; i < colSpan; i++) {\r\n                colsSpanning.push(pointer);\r\n                pointer = this.beans.columnController.getDisplayedColAfter(pointer);\r\n                if (utils_1._.missing(pointer)) {\r\n                    break;\r\n                }\r\n                // we do not allow col spanning to span outside of pinned areas\r\n                if (pinned !== pointer.getPinned()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return colsSpanning;\r\n    };\r\n    CellComp.prototype.onDisplayColumnsChanged = function () {\r\n        var colsSpanning = this.getColSpanningList();\r\n        if (!utils_1._.compareArrays(this.colsSpanning, colsSpanning)) {\r\n            this.colsSpanning = colsSpanning;\r\n            this.onWidthChanged();\r\n            this.onLeftChanged(); // left changes when doing RTL\r\n        }\r\n    };\r\n    CellComp.prototype.getInitialCssClasses = function () {\r\n        var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"];\r\n        // if we are putting the cell into a dummy container, to work out it's height,\r\n        // then we don't put the height css in, as we want cell to fit height in that case.\r\n        if (!this.autoHeightCell) {\r\n            cssClasses.push('ag-cell-with-height');\r\n        }\r\n        var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\r\n        if (doingFocusCss) {\r\n            // otherwise the class depends on the focus state\r\n            cssClasses.push(this.cellFocused ? 'ag-cell-focus' : 'ag-cell-no-focus');\r\n        }\r\n        else {\r\n            // if we are not doing cell selection, then ag-cell-no-focus gets put onto every cell\r\n            cssClasses.push('ag-cell-no-focus');\r\n        }\r\n        if (this.firstRightPinned) {\r\n            cssClasses.push('ag-cell-first-right-pinned');\r\n        }\r\n        if (this.lastLeftPinned) {\r\n            cssClasses.push('ag-cell-last-left-pinned');\r\n        }\r\n        if (this.beans.columnHoverService.isHovered(this.column)) {\r\n            cssClasses.push('ag-column-hover');\r\n        }\r\n        utils_1._.pushAll(cssClasses, this.preProcessClassesFromColDef());\r\n        utils_1._.pushAll(cssClasses, this.preProcessCellClassRules());\r\n        utils_1._.pushAll(cssClasses, this.getRangeClasses());\r\n        // if using the wrapper, this class goes on the wrapper instead\r\n        if (!this.usingWrapper) {\r\n            cssClasses.push('ag-cell-value');\r\n        }\r\n        return cssClasses;\r\n    };\r\n    CellComp.prototype.getInitialValueToRender = function () {\r\n        // if using a cellRenderer, then render the html from the cell renderer if it exists\r\n        if (this.usingCellRenderer) {\r\n            if (typeof this.cellRendererGui === 'string') {\r\n                return this.cellRendererGui;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        }\r\n        var colDef = this.column.getColDef();\r\n        if (colDef.template) {\r\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\r\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\r\n            return colDef.template;\r\n        }\r\n        else if (colDef.templateUrl) {\r\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\r\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\r\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\r\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\r\n            if (template) {\r\n                return template;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        }\r\n        else {\r\n            return this.getValueToUse();\r\n        }\r\n    };\r\n    CellComp.prototype.getRenderedRow = function () {\r\n        return this.rowComp;\r\n    };\r\n    CellComp.prototype.isSuppressNavigable = function () {\r\n        return this.column.isSuppressNavigable(this.rowNode);\r\n    };\r\n    CellComp.prototype.getCellRenderer = function () {\r\n        return this.cellRenderer;\r\n    };\r\n    CellComp.prototype.getCellEditor = function () {\r\n        return this.cellEditor;\r\n    };\r\n    // + stop editing {forceRefresh: true, suppressFlash: true}\r\n    // + event cellChanged {}\r\n    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\r\n    // + rowComp: event dataChanged {animate: update, newData: !update}\r\n    // + rowComp: api refreshCells() {animate: true/false}\r\n    // + rowRenderer: api softRefreshView() {}\r\n    CellComp.prototype.refreshCell = function (params) {\r\n        if (this.editingCell) {\r\n            return;\r\n        }\r\n        var newData = params && params.newData;\r\n        var suppressFlash = (params && params.suppressFlash) || this.column.getColDef().suppressCellFlash;\r\n        var forceRefresh = params && params.forceRefresh;\r\n        var oldValue = this.value;\r\n        this.getValueAndFormat();\r\n        // for simple values only (not pojo's), see if the value is the same, and if it is, skip the refresh.\r\n        // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\r\n        // if was before the edit.\r\n        var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\r\n        var dataNeedsUpdating = forceRefresh || valuesDifferent;\r\n        if (dataNeedsUpdating) {\r\n            var cellRendererRefreshed = void 0;\r\n            // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\r\n            // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\r\n            // then we are not showing a movement in the stock price, rather we are showing different stock.\r\n            if (newData || suppressFlash) {\r\n                cellRendererRefreshed = false;\r\n            }\r\n            else {\r\n                cellRendererRefreshed = this.attemptCellRendererRefresh();\r\n            }\r\n            // we do the replace if not doing refresh, or if refresh was unsuccessful.\r\n            // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\r\n            // wrapper has the refresh method, but the underlying component doesn't\r\n            if (!cellRendererRefreshed) {\r\n                this.replaceContentsAfterRefresh();\r\n            }\r\n            if (!suppressFlash) {\r\n                var flashCell = this.beans.gridOptionsWrapper.isEnableCellChangeFlash()\r\n                    || this.column.getColDef().enableCellChangeFlash;\r\n                if (flashCell) {\r\n                    this.flashCell();\r\n                }\r\n            }\r\n            // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\r\n            this.postProcessStylesFromColDef();\r\n            this.postProcessClassesFromColDef();\r\n        }\r\n        this.refreshToolTip();\r\n        // we do cellClassRules even if the value has not changed, so that users who have rules that\r\n        // look at other parts of the row (where the other part of the row might of changed) will work.\r\n        this.postProcessCellClassRules();\r\n    };\r\n    // user can also call this via API\r\n    CellComp.prototype.flashCell = function () {\r\n        this.animateCell('data-changed');\r\n    };\r\n    CellComp.prototype.animateCell = function (cssName) {\r\n        var fullName = 'ag-cell-' + cssName;\r\n        var animationFullName = 'ag-cell-' + cssName + '-animation';\r\n        var element = this.getGui();\r\n        // we want to highlight the cells, without any animation\r\n        utils_1._.addCssClass(element, fullName);\r\n        utils_1._.removeCssClass(element, animationFullName);\r\n        // then once that is applied, we remove the highlight with animation\r\n        setTimeout(function () {\r\n            utils_1._.removeCssClass(element, fullName);\r\n            utils_1._.addCssClass(element, animationFullName);\r\n            setTimeout(function () {\r\n                // and then to leave things as we got them, we remove the animation\r\n                utils_1._.removeCssClass(element, animationFullName);\r\n            }, 1000);\r\n        }, 500);\r\n    };\r\n    CellComp.prototype.replaceContentsAfterRefresh = function () {\r\n        // otherwise we rip out the cell and replace it\r\n        utils_1._.removeAllChildren(this.eParentOfValue);\r\n        // remove old renderer component if it exists\r\n        if (this.cellRenderer && this.cellRenderer.destroy) {\r\n            this.cellRenderer.destroy();\r\n        }\r\n        this.cellRenderer = null;\r\n        this.cellRendererGui = null;\r\n        // populate\r\n        this.putDataIntoCellAfterRefresh();\r\n        this.angular1Compile();\r\n    };\r\n    CellComp.prototype.angular1Compile = function () {\r\n        // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\r\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\r\n            var eGui = this.getGui();\r\n            var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\r\n            this.addDestroyFunc(function () {\r\n                compiledElement_1.remove();\r\n            });\r\n        }\r\n    };\r\n    CellComp.prototype.postProcessStylesFromColDef = function () {\r\n        var stylesToUse = this.processStylesFromColDef();\r\n        if (stylesToUse) {\r\n            utils_1._.addStylesToElement(this.getGui(), stylesToUse);\r\n        }\r\n    };\r\n    CellComp.prototype.preProcessStylesFromColDef = function () {\r\n        var stylesToUse = this.processStylesFromColDef();\r\n        return utils_1._.cssStyleObjectToMarkup(stylesToUse);\r\n    };\r\n    CellComp.prototype.processStylesFromColDef = function () {\r\n        var colDef = this.column.getColDef();\r\n        if (colDef.cellStyle) {\r\n            var cssToUse = void 0;\r\n            if (typeof colDef.cellStyle === 'function') {\r\n                var cellStyleParams = {\r\n                    value: this.value,\r\n                    data: this.rowNode.data,\r\n                    node: this.rowNode,\r\n                    colDef: colDef,\r\n                    column: this.column,\r\n                    $scope: this.scope,\r\n                    context: this.beans.gridOptionsWrapper.getContext(),\r\n                    api: this.beans.gridOptionsWrapper.getApi()\r\n                };\r\n                var cellStyleFunc = colDef.cellStyle;\r\n                cssToUse = cellStyleFunc(cellStyleParams);\r\n            }\r\n            else {\r\n                cssToUse = colDef.cellStyle;\r\n            }\r\n            return cssToUse;\r\n        }\r\n    };\r\n    CellComp.prototype.postProcessClassesFromColDef = function () {\r\n        var _this = this;\r\n        this.processClassesFromColDef(function (className) { return utils_1._.addCssClass(_this.getGui(), className); });\r\n    };\r\n    CellComp.prototype.preProcessClassesFromColDef = function () {\r\n        var res = [];\r\n        this.processClassesFromColDef(function (className) { return res.push(className); });\r\n        return res;\r\n    };\r\n    CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\r\n        this.beans.stylingService.processStaticCellClasses(this.column.getColDef(), {\r\n            value: this.value,\r\n            data: this.rowNode.data,\r\n            node: this.rowNode,\r\n            colDef: this.column.getColDef(),\r\n            rowIndex: this.rowNode.rowIndex,\r\n            $scope: this.scope,\r\n            api: this.beans.gridOptionsWrapper.getApi(),\r\n            context: this.beans.gridOptionsWrapper.getContext()\r\n        }, onApplicableClass);\r\n    };\r\n    CellComp.prototype.putDataIntoCellAfterRefresh = function () {\r\n        // template gets preference, then cellRenderer, then do it ourselves\r\n        var colDef = this.column.getColDef();\r\n        if (colDef.template) {\r\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\r\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\r\n            this.eParentOfValue.innerHTML = colDef.template;\r\n        }\r\n        else if (colDef.templateUrl) {\r\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\r\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\r\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\r\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\r\n            if (template) {\r\n                this.eParentOfValue.innerHTML = template;\r\n            }\r\n            // use cell renderer if it exists\r\n        }\r\n        else if (this.usingCellRenderer) {\r\n            this.attachCellRenderer();\r\n        }\r\n        else {\r\n            var valueToUse = this.getValueToUse();\r\n            if (valueToUse !== null && valueToUse !== undefined) {\r\n                this.eParentOfValue.innerText = valueToUse;\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.attemptCellRendererRefresh = function () {\r\n        if (utils_1._.missing(this.cellRenderer) || utils_1._.missing(this.cellRenderer.refresh)) {\r\n            return false;\r\n        }\r\n        // if the cell renderer has a refresh method, we call this instead of doing a refresh\r\n        // note: should pass in params here instead of value?? so that client has formattedValue\r\n        var params = this.createCellRendererParams();\r\n        var result = this.cellRenderer.refresh(params);\r\n        // NOTE on undefined: previous version of the cellRenderer.refresh() interface\r\n        // returned nothing, if the method existed, we assumed it refreshed. so for\r\n        // backwards compatibility, we assume if method exists and returns nothing,\r\n        // that it was successful.\r\n        return result === true || result === undefined;\r\n    };\r\n    CellComp.prototype.refreshToolTip = function () {\r\n        var newTooltip = this.getToolTip();\r\n        if (this.tooltip !== newTooltip) {\r\n            this.tooltip = newTooltip;\r\n            if (utils_1._.exists(newTooltip)) {\r\n                var tooltipSanitised = utils_1._.escape(this.tooltip);\r\n                this.eParentOfValue.setAttribute('title', tooltipSanitised);\r\n            }\r\n            else {\r\n                this.eParentOfValue.removeAttribute('title');\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.valuesAreEqual = function (val1, val2) {\r\n        // if the user provided an equals method, use that, otherwise do simple comparison\r\n        var colDef = this.column.getColDef();\r\n        var equalsMethod = colDef ? colDef.equals : null;\r\n        if (equalsMethod) {\r\n            return equalsMethod(val1, val2);\r\n        }\r\n        else {\r\n            return val1 === val2;\r\n        }\r\n    };\r\n    CellComp.prototype.getToolTip = function () {\r\n        var colDef = this.column.getColDef();\r\n        var data = this.rowNode.data;\r\n        if (colDef.tooltipField && utils_1._.exists(data)) {\r\n            return utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\r\n        }\r\n        else if (colDef.tooltip) {\r\n            return colDef.tooltip({\r\n                value: this.value,\r\n                valueFormatted: this.valueFormatted,\r\n                data: this.rowNode.data,\r\n                node: this.rowNode,\r\n                colDef: this.column.getColDef(),\r\n                api: this.beans.gridOptionsWrapper.getApi(),\r\n                $scope: this.scope,\r\n                context: this.beans.gridOptionsWrapper.getContext(),\r\n                rowIndex: this.gridCell.rowIndex\r\n            });\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\r\n        this.beans.stylingService.processClassRules(this.column.getColDef().cellClassRules, {\r\n            value: this.value,\r\n            data: this.rowNode.data,\r\n            node: this.rowNode,\r\n            colDef: this.column.getColDef(),\r\n            rowIndex: this.gridCell.rowIndex,\r\n            api: this.beans.gridOptionsWrapper.getApi(),\r\n            $scope: this.scope,\r\n            context: this.beans.gridOptionsWrapper.getContext()\r\n        }, onApplicableClass, onNotApplicableClass);\r\n    };\r\n    CellComp.prototype.postProcessCellClassRules = function () {\r\n        var _this = this;\r\n        this.processCellClassRules(function (className) {\r\n            utils_1._.addCssClass(_this.getGui(), className);\r\n        }, function (className) {\r\n            utils_1._.removeCssClass(_this.getGui(), className);\r\n        });\r\n    };\r\n    CellComp.prototype.preProcessCellClassRules = function () {\r\n        var res = [];\r\n        this.processCellClassRules(function (className) {\r\n            res.push(className);\r\n        }, function (className) {\r\n            // not catered for, if creating, no need\r\n            // to remove class as it was never there\r\n        });\r\n        return res;\r\n    };\r\n    // a wrapper is used when we are putting a selection checkbox in the cell with the value\r\n    CellComp.prototype.setUsingWrapper = function () {\r\n        var colDef = this.column.getColDef();\r\n        // never allow selection or dragging on pinned rows\r\n        if (this.rowNode.rowPinned) {\r\n            this.usingWrapper = false;\r\n            this.includeSelectionComponent = false;\r\n            this.includeRowDraggingComponent = false;\r\n            return;\r\n        }\r\n        var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\r\n        var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\r\n        this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\r\n        this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\r\n        this.usingWrapper = this.includeRowDraggingComponent || this.includeSelectionComponent;\r\n    };\r\n    CellComp.prototype.chooseCellRenderer = function () {\r\n        // template gets preference, then cellRenderer, then do it ourselves\r\n        var colDef = this.column.getColDef();\r\n        // templates are for ng1, ideally we wouldn't have these, they are ng1 support\r\n        // inside the core which is bad\r\n        if (colDef.template || colDef.templateUrl) {\r\n            this.usingCellRenderer = false;\r\n            return;\r\n        }\r\n        var params = this.createCellRendererParams();\r\n        var cellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'cellRenderer', params, null);\r\n        var pinnedRowCellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'pinnedRowCellRenderer', params, null);\r\n        if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\r\n            this.cellRendererType = 'pinnedRowCellRenderer';\r\n            this.usingCellRenderer = true;\r\n        }\r\n        else if (cellRenderer) {\r\n            this.cellRendererType = 'cellRenderer';\r\n            this.usingCellRenderer = true;\r\n        }\r\n        else {\r\n            this.usingCellRenderer = false;\r\n        }\r\n    };\r\n    CellComp.prototype.createCellRendererInstance = function () {\r\n        var params = this.createCellRendererParams();\r\n        this.cellRendererVersion++;\r\n        var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\r\n        this.beans.componentResolver.createAgGridComponent(this.column.getColDef(), params, this.cellRendererType, params, null).then(callback);\r\n    };\r\n    CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\r\n        // see if daemon\r\n        if (cellRendererVersion !== this.cellRendererVersion) {\r\n            if (cellRenderer.destroy) {\r\n                cellRenderer.destroy();\r\n            }\r\n            return;\r\n        }\r\n        this.cellRenderer = cellRenderer;\r\n        this.cellRendererGui = this.cellRenderer.getGui();\r\n        if (utils_1._.missing(this.cellRendererGui)) {\r\n            return;\r\n        }\r\n        // if async components, then it's possible the user started editing since\r\n        // this call was made\r\n        if (!this.editingCell) {\r\n            this.eParentOfValue.appendChild(this.cellRendererGui);\r\n        }\r\n    };\r\n    CellComp.prototype.attachCellRenderer = function () {\r\n        if (!this.usingCellRenderer) {\r\n            return;\r\n        }\r\n        this.createCellRendererInstance();\r\n    };\r\n    CellComp.prototype.createCellRendererParams = function () {\r\n        var _this = this;\r\n        var params = {\r\n            value: this.value,\r\n            valueFormatted: this.valueFormatted,\r\n            getValue: this.getValue.bind(this),\r\n            setValue: function (value) {\r\n                _this.beans.valueService.setValue(_this.rowNode, _this.column, value);\r\n            },\r\n            formatValue: this.formatValue.bind(this),\r\n            data: this.rowNode.data,\r\n            node: this.rowNode,\r\n            colDef: this.column.getColDef(),\r\n            column: this.column,\r\n            $scope: this.scope,\r\n            rowIndex: this.gridCell.rowIndex,\r\n            api: this.beans.gridOptionsWrapper.getApi(),\r\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\r\n            context: this.beans.gridOptionsWrapper.getContext(),\r\n            refreshCell: this.refreshCell.bind(this),\r\n            eGridCell: this.getGui(),\r\n            eParentOfValue: this.eParentOfValue,\r\n            // these bits are not documented anywhere, so we could drop them?\r\n            // it was in the olden days to allow user to register for when rendered\r\n            // row was removed (the row comp was removed), however now that the user\r\n            // can provide components for cells, the destroy method gets call when this\r\n            // happens so no longer need to fire event.\r\n            addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\r\n            addRenderedRowListener: function (eventType, listener) {\r\n                console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\r\n                if (_this.rowComp) {\r\n                    _this.rowComp.addEventListener(eventType, listener);\r\n                }\r\n            }\r\n        };\r\n        return params;\r\n    };\r\n    CellComp.prototype.formatValue = function (value) {\r\n        var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\r\n        var valueFormattedExists = valueFormatted !== null && valueFormatted !== undefined;\r\n        return valueFormattedExists ? valueFormatted : value;\r\n    };\r\n    CellComp.prototype.getValueToUse = function () {\r\n        var valueFormattedExists = this.valueFormatted !== null && this.valueFormatted !== undefined;\r\n        return valueFormattedExists ? this.valueFormatted : this.value;\r\n    };\r\n    CellComp.prototype.getValueAndFormat = function () {\r\n        this.value = this.getValue();\r\n        this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\r\n    };\r\n    CellComp.prototype.getValue = function () {\r\n        // if we don't check this, then the grid will render leaf groups as open even if we are not\r\n        // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\r\n        // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\r\n        // them via the API, or user user expanded them in the UI before turning on pivot mode\r\n        var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\r\n        var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup;\r\n        if (isOpenGroup && this.beans.gridOptionsWrapper.isGroupIncludeFooter()) {\r\n            // if doing grouping and footers, we don't want to include the agg value\r\n            // in the header when the group is open\r\n            return this.beans.valueService.getValue(this.column, this.rowNode, false, true);\r\n        }\r\n        else {\r\n            return this.beans.valueService.getValue(this.column, this.rowNode);\r\n        }\r\n    };\r\n    CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\r\n        if (utils_1._.isStopPropagationForAgGrid(mouseEvent)) {\r\n            return;\r\n        }\r\n        switch (eventName) {\r\n            case 'click':\r\n                this.onCellClicked(mouseEvent);\r\n                break;\r\n            case 'mousedown':\r\n                this.onMouseDown(mouseEvent);\r\n                break;\r\n            case 'dblclick':\r\n                this.onCellDoubleClicked(mouseEvent);\r\n                break;\r\n            case 'mouseout':\r\n                this.onMouseOut(mouseEvent);\r\n                break;\r\n            case 'mouseover':\r\n                this.onMouseOver(mouseEvent);\r\n                break;\r\n        }\r\n    };\r\n    CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\r\n        var colDef = this.column.getColDef();\r\n        var cellContextMenuEvent = this.createEvent(event, events_1.Events.EVENT_CELL_CONTEXT_MENU);\r\n        this.beans.eventService.dispatchEvent(cellContextMenuEvent);\r\n        if (colDef.onCellContextMenu) {\r\n            // to make the callback async, do in a timeout\r\n            setTimeout(function () { return colDef.onCellContextMenu(cellContextMenuEvent); }, 0);\r\n        }\r\n    };\r\n    CellComp.prototype.createEvent = function (domEvent, eventType) {\r\n        var event = {\r\n            node: this.rowNode,\r\n            data: this.rowNode.data,\r\n            value: this.value,\r\n            column: this.column,\r\n            colDef: this.column.getColDef(),\r\n            context: this.beans.gridOptionsWrapper.getContext(),\r\n            api: this.beans.gridApi,\r\n            columnApi: this.beans.columnApi,\r\n            rowPinned: this.rowNode.rowPinned,\r\n            event: domEvent,\r\n            type: eventType,\r\n            rowIndex: this.rowNode.rowIndex\r\n        };\r\n        // because we are hacking in $scope for angular 1, we have to de-reference\r\n        if (this.scope) {\r\n            event.$scope = this.scope;\r\n        }\r\n        return event;\r\n    };\r\n    CellComp.prototype.onMouseOut = function (mouseEvent) {\r\n        var cellMouseOutEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OUT);\r\n        this.beans.eventService.dispatchEvent(cellMouseOutEvent);\r\n        this.beans.columnHoverService.clearMouseOver();\r\n    };\r\n    CellComp.prototype.onMouseOver = function (mouseEvent) {\r\n        var cellMouseOverEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OVER);\r\n        this.beans.eventService.dispatchEvent(cellMouseOverEvent);\r\n        this.beans.columnHoverService.setMouseOver([this.column]);\r\n    };\r\n    CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\r\n        var colDef = this.column.getColDef();\r\n        // always dispatch event to eventService\r\n        var cellDoubleClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_DOUBLE_CLICKED);\r\n        this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);\r\n        // check if colDef also wants to handle event\r\n        if (typeof colDef.onCellDoubleClicked === 'function') {\r\n            // to make the callback async, do in a timeout\r\n            setTimeout(function () { return colDef.onCellDoubleClicked(cellDoubleClickedEvent); }, 0);\r\n        }\r\n        var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit()\r\n            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\r\n        if (editOnDoubleClick) {\r\n            this.startRowOrCellEdit();\r\n        }\r\n    };\r\n    // called by rowRenderer when user navigates via tab key\r\n    CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\r\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\r\n            this.rowComp.startRowEditing(keyPress, charPress, this);\r\n        }\r\n        else {\r\n            this.startEditingIfEnabled(keyPress, charPress, true);\r\n        }\r\n    };\r\n    CellComp.prototype.isCellEditable = function () {\r\n        return this.column.isCellEditable(this.rowNode);\r\n    };\r\n    // either called internally if single cell editing, or called by rowRenderer if row editing\r\n    CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\r\n        if (keyPress === void 0) {\r\n            keyPress = null;\r\n        }\r\n        if (charPress === void 0) {\r\n            charPress = null;\r\n        }\r\n        if (cellStartedEdit === void 0) {\r\n            cellStartedEdit = false;\r\n        }\r\n        // don't do it if not editable\r\n        if (!this.isCellEditable()) {\r\n            return;\r\n        }\r\n        // don't do it if already editing\r\n        if (this.editingCell) {\r\n            return;\r\n        }\r\n        this.editingCell = true;\r\n        this.cellEditorVersion++;\r\n        var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\r\n        var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\r\n        this.beans.cellEditorFactory.createCellEditor(this.column.getColDef(), params).then(callback);\r\n        // if we don't do this, and editor component is async, then there will be a period\r\n        // when the component isn't present and keyboard navigation won't work - so example\r\n        // of user hitting tab quickly (more quickly than renderers getting created) won't work\r\n        var cellEditorAsync = utils_1._.missing(this.cellEditor);\r\n        if (cellEditorAsync && cellStartedEdit) {\r\n            this.focusCell(true);\r\n        }\r\n    };\r\n    CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\r\n        // if editingCell=false, means user cancelled the editor before component was ready.\r\n        // if versionMismatch, then user cancelled the edit, then started the edit again, and this\r\n        //   is the first editor which is now stale.\r\n        var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\r\n        if (versionMismatch || !this.editingCell) {\r\n            if (cellEditor.destroy) {\r\n                cellEditor.destroy();\r\n            }\r\n            return;\r\n        }\r\n        if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {\r\n            if (cellEditor.destroy) {\r\n                cellEditor.destroy();\r\n            }\r\n            this.editingCell = false;\r\n            return;\r\n        }\r\n        if (!cellEditor.getGui) {\r\n            console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\");\r\n            // no getGui, for React guys, see if they attached a react component directly\r\n            if (cellEditor.render) {\r\n                console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\r\n            }\r\n            if (cellEditor.destroy) {\r\n                cellEditor.destroy();\r\n            }\r\n            this.editingCell = false;\r\n            return;\r\n        }\r\n        this.cellEditor = cellEditor;\r\n        this.cellEditorInPopup = cellEditor.isPopup && cellEditor.isPopup();\r\n        this.setInlineEditingClass();\r\n        if (this.cellEditorInPopup) {\r\n            this.addPopupCellEditor();\r\n        }\r\n        else {\r\n            this.addInCellEditor();\r\n        }\r\n        if (cellEditor.afterGuiAttached) {\r\n            cellEditor.afterGuiAttached();\r\n        }\r\n        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STARTED);\r\n        this.beans.eventService.dispatchEvent(event);\r\n    };\r\n    CellComp.prototype.addInCellEditor = function () {\r\n        utils_1._.removeAllChildren(this.getGui());\r\n        this.getGui().appendChild(this.cellEditor.getGui());\r\n        this.angular1Compile();\r\n    };\r\n    CellComp.prototype.addPopupCellEditor = function () {\r\n        var _this = this;\r\n        var ePopupGui = this.cellEditor.getGui();\r\n        this.hideEditorPopup = this.beans.popupService.addAsModalPopup(ePopupGui, true, \r\n        // callback for when popup disappears\r\n        function () {\r\n            _this.onPopupEditorClosed();\r\n        });\r\n        this.beans.popupService.positionPopupOverComponent({\r\n            column: this.column,\r\n            rowNode: this.rowNode,\r\n            type: 'popupCellEditor',\r\n            eventSource: this.getGui(),\r\n            ePopup: ePopupGui,\r\n            keepWithinBounds: true\r\n        });\r\n        this.angular1Compile();\r\n    };\r\n    CellComp.prototype.onPopupEditorClosed = function () {\r\n        // we only call stopEditing if we are editing, as\r\n        // it's possible the popup called 'stop editing'\r\n        // before this, eg if 'enter key' was pressed on\r\n        // the editor.\r\n        if (this.editingCell) {\r\n            // note: this only happens when use clicks outside of the grid. if use clicks on another\r\n            // cell, then the editing will have already stopped on this cell\r\n            this.stopRowOrCellEdit();\r\n            // we only focus cell again if this cell is still focused. it is possible\r\n            // it is not focused if the user cancelled the edit by clicking on another\r\n            // cell outside of this one\r\n            if (this.beans.focusedCellController.isCellFocused(this.gridCell)) {\r\n                this.focusCell(true);\r\n            }\r\n        }\r\n    };\r\n    // if we are editing inline, then we don't have the padding in the cell (set in the themes)\r\n    // to allow the text editor full access to the entire cell\r\n    CellComp.prototype.setInlineEditingClass = function () {\r\n        var editingInline = this.editingCell && !this.cellEditorInPopup;\r\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-inline-editing', editingInline);\r\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-not-inline-editing', !editingInline);\r\n    };\r\n    CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\r\n        var params = {\r\n            value: this.getValue(),\r\n            keyPress: keyPress,\r\n            charPress: charPress,\r\n            column: this.column,\r\n            rowIndex: this.gridCell.rowIndex,\r\n            node: this.rowNode,\r\n            api: this.beans.gridOptionsWrapper.getApi(),\r\n            cellStartedEdit: cellStartedEdit,\r\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\r\n            context: this.beans.gridOptionsWrapper.getContext(),\r\n            $scope: this.scope,\r\n            onKeyDown: this.onKeyDown.bind(this),\r\n            stopEditing: this.stopEditingAndFocus.bind(this),\r\n            eGridCell: this.getGui(),\r\n            parseValue: this.parseValue.bind(this),\r\n            formatValue: this.formatValue.bind(this)\r\n        };\r\n        return params;\r\n    };\r\n    // cell editors call this, when they want to stop for reasons other\r\n    // than what we pick up on. eg selecting from a dropdown ends editing.\r\n    CellComp.prototype.stopEditingAndFocus = function () {\r\n        this.stopRowOrCellEdit();\r\n        this.focusCell(true);\r\n        this.navigateAfterEdit();\r\n    };\r\n    CellComp.prototype.parseValue = function (newValue) {\r\n        var params = {\r\n            node: this.rowNode,\r\n            data: this.rowNode.data,\r\n            oldValue: this.value,\r\n            newValue: newValue,\r\n            colDef: this.column.getColDef(),\r\n            column: this.column,\r\n            api: this.beans.gridOptionsWrapper.getApi(),\r\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\r\n            context: this.beans.gridOptionsWrapper.getContext()\r\n        };\r\n        var valueParser = this.column.getColDef().valueParser;\r\n        return utils_1._.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\r\n    };\r\n    CellComp.prototype.focusCell = function (forceBrowserFocus) {\r\n        if (forceBrowserFocus === void 0) {\r\n            forceBrowserFocus = false;\r\n        }\r\n        this.beans.focusedCellController.setFocusedCell(this.gridCell.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\r\n    };\r\n    CellComp.prototype.setFocusInOnEditor = function () {\r\n        if (this.editingCell) {\r\n            if (this.cellEditor && this.cellEditor.focusIn) {\r\n                // if the editor is present, then we just focus it\r\n                this.cellEditor.focusIn();\r\n            }\r\n            else {\r\n                // if the editor is not present, it means async cell editor (eg React fibre)\r\n                // and we are trying to set focus before the cell editor is present, so we\r\n                // focus the cell instead\r\n                this.focusCell(true);\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.isEditing = function () {\r\n        return this.editingCell;\r\n    };\r\n    CellComp.prototype.onKeyDown = function (event) {\r\n        var key = event.which || event.keyCode;\r\n        // give user a chance to cancel event processing\r\n        if (this.doesUserWantToCancelKeyboardEvent(event)) {\r\n            return;\r\n        }\r\n        switch (key) {\r\n            case constants_1.Constants.KEY_ENTER:\r\n                this.onEnterKeyDown();\r\n                break;\r\n            case constants_1.Constants.KEY_F2:\r\n                this.onF2KeyDown();\r\n                break;\r\n            case constants_1.Constants.KEY_ESCAPE:\r\n                this.onEscapeKeyDown();\r\n                break;\r\n            case constants_1.Constants.KEY_TAB:\r\n                this.onTabKeyDown(event);\r\n                break;\r\n            case constants_1.Constants.KEY_BACKSPACE:\r\n            case constants_1.Constants.KEY_DELETE:\r\n                this.onBackspaceOrDeleteKeyPressed(key);\r\n                break;\r\n            case constants_1.Constants.KEY_DOWN:\r\n            case constants_1.Constants.KEY_UP:\r\n            case constants_1.Constants.KEY_RIGHT:\r\n            case constants_1.Constants.KEY_LEFT:\r\n                this.onNavigationKeyPressed(event, key);\r\n                break;\r\n        }\r\n    };\r\n    CellComp.prototype.doesUserWantToCancelKeyboardEvent = function (event) {\r\n        var callback = this.column.getColDef().suppressKeyboardEvent;\r\n        if (utils_1._.missing(callback)) {\r\n            return false;\r\n        }\r\n        else {\r\n            // if editing is null or undefined, this sets it to false\r\n            var params = {\r\n                event: event,\r\n                editing: this.editingCell,\r\n                column: this.column,\r\n                api: this.beans.gridOptionsWrapper.getApi(),\r\n                node: this.rowNode,\r\n                data: this.rowNode.data,\r\n                colDef: this.column.getColDef(),\r\n                context: this.beans.gridOptionsWrapper.getContext(),\r\n                columnApi: this.beans.gridOptionsWrapper.getColumnApi()\r\n            };\r\n            return callback(params);\r\n        }\r\n    };\r\n    CellComp.prototype.setFocusOutOnEditor = function () {\r\n        if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\r\n            this.cellEditor.focusOut();\r\n        }\r\n    };\r\n    CellComp.prototype.onNavigationKeyPressed = function (event, key) {\r\n        if (this.editingCell) {\r\n            this.stopRowOrCellEdit();\r\n        }\r\n        if (event.shiftKey && this.rangeSelectionEnabled) {\r\n            this.onShiftRangeSelect(key);\r\n        }\r\n        else {\r\n            this.beans.rowRenderer.navigateToNextCell(event, key, this.gridCell, true);\r\n        }\r\n        // if we don't prevent default, the grid will scroll with the navigation keys\r\n        event.preventDefault();\r\n    };\r\n    CellComp.prototype.onShiftRangeSelect = function (key) {\r\n        var success = this.beans.rangeController.extendRangeInDirection(this.gridCell, key);\r\n        if (!success) {\r\n            return;\r\n        }\r\n        var ranges = this.beans.rangeController.getCellRanges();\r\n        // this should never happen, as extendRangeFromCell should always have one range after getting called\r\n        if (utils_1._.missing(ranges) || ranges.length !== 1) {\r\n            return;\r\n        }\r\n        var endCell = ranges[0].end;\r\n        this.beans.rowRenderer.ensureCellVisible(endCell);\r\n    };\r\n    CellComp.prototype.onTabKeyDown = function (event) {\r\n        if (this.beans.gridOptionsWrapper.isSuppressTabbing()) {\r\n            return;\r\n        }\r\n        this.beans.rowRenderer.onTabKeyDown(this, event);\r\n    };\r\n    CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\r\n        if (!this.editingCell) {\r\n            this.startRowOrCellEdit(key);\r\n        }\r\n    };\r\n    CellComp.prototype.onEnterKeyDown = function () {\r\n        if (this.editingCell || this.rowComp.isEditing()) {\r\n            this.stopEditingAndFocus();\r\n        }\r\n        else {\r\n            if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\r\n                this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.gridCell, false);\r\n            }\r\n            else {\r\n                this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.navigateAfterEdit = function () {\r\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\r\n        if (fullRowEdit) {\r\n            return;\r\n        }\r\n        var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\r\n        if (enterMovesDownAfterEdit) {\r\n            this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.gridCell, false);\r\n        }\r\n    };\r\n    CellComp.prototype.onF2KeyDown = function () {\r\n        if (!this.editingCell) {\r\n            this.startRowOrCellEdit(constants_1.Constants.KEY_F2);\r\n        }\r\n    };\r\n    CellComp.prototype.onEscapeKeyDown = function () {\r\n        if (this.editingCell) {\r\n            this.stopRowOrCellEdit(true);\r\n            this.focusCell(true);\r\n        }\r\n    };\r\n    CellComp.prototype.onKeyPress = function (event) {\r\n        // check this, in case focus is on a (for example) a text field inside the cell,\r\n        // in which cse we should not be listening for these key pressed\r\n        var eventTarget = utils_1._.getTarget(event);\r\n        var eventOnChildComponent = eventTarget !== this.getGui();\r\n        if (eventOnChildComponent) {\r\n            return;\r\n        }\r\n        if (!this.editingCell) {\r\n            var pressedChar = String.fromCharCode(event.charCode);\r\n            if (pressedChar === ' ') {\r\n                this.onSpaceKeyPressed(event);\r\n            }\r\n            else {\r\n                if (utils_1._.isEventFromPrintableCharacter(event)) {\r\n                    this.startRowOrCellEdit(null, pressedChar);\r\n                    // if we don't prevent default, then the keypress also gets applied to the text field\r\n                    // (at least when doing the default editor), but we need to allow the editor to decide\r\n                    // what it wants to do. we only do this IF editing was started - otherwise it messes\r\n                    // up when the use is not doing editing, but using rendering with text fields in cellRenderer\r\n                    // (as it would block the the user from typing into text fields).\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.onSpaceKeyPressed = function (event) {\r\n        if (!this.editingCell && this.beans.gridOptionsWrapper.isRowSelection()) {\r\n            var selected = this.rowNode.isSelected();\r\n            this.rowNode.setSelected(!selected);\r\n        }\r\n        // prevent default as space key, by default, moves browser scroll down\r\n        event.preventDefault();\r\n    };\r\n    CellComp.prototype.onMouseDown = function (mouseEvent) {\r\n        // we pass false to focusCell, as we don't want the cell to focus\r\n        // also get the browser focus. if we did, then the cellRenderer could\r\n        // have a text field in it, for example, and as the user clicks on the\r\n        // text field, the text field, the focus doesn't get to the text\r\n        // field, instead to goes to the div behind, making it impossible to\r\n        // select the text field.\r\n        this.focusCell(false);\r\n        // if it's a right click, then if the cell is already in range,\r\n        // don't change the range, however if the cell is not in a range,\r\n        // we set a new range\r\n        if (this.beans.rangeController) {\r\n            var thisCell = this.gridCell;\r\n            if (mouseEvent.shiftKey) {\r\n                this.beans.rangeController.extendRangeToCell(thisCell);\r\n            }\r\n            else {\r\n                var cellAlreadyInRange = this.beans.rangeController.isCellInAnyRange(thisCell);\r\n                if (!cellAlreadyInRange) {\r\n                    this.beans.rangeController.setRangeToCell(thisCell);\r\n                }\r\n            }\r\n        }\r\n        var cellMouseDownEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_DOWN);\r\n        this.beans.eventService.dispatchEvent(cellMouseDownEvent);\r\n    };\r\n    // returns true if on iPad and this is second 'click' event in 200ms\r\n    CellComp.prototype.isDoubleClickOnIPad = function () {\r\n        if (!utils_1._.isUserAgentIPad()) {\r\n            return false;\r\n        }\r\n        var nowMillis = new Date().getTime();\r\n        var res = nowMillis - this.lastIPadMouseClickEvent < 200;\r\n        this.lastIPadMouseClickEvent = nowMillis;\r\n        return res;\r\n    };\r\n    CellComp.prototype.onCellClicked = function (mouseEvent) {\r\n        // iPad doesn't have double click - so we need to mimic it do enable editing for\r\n        // iPad.\r\n        if (this.isDoubleClickOnIPad()) {\r\n            this.onCellDoubleClicked(mouseEvent);\r\n            mouseEvent.preventDefault(); // if we don't do this, then ipad zooms in\r\n            return;\r\n        }\r\n        var cellClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CLICKED);\r\n        this.beans.eventService.dispatchEvent(cellClickedEvent);\r\n        var colDef = this.column.getColDef();\r\n        if (colDef.onCellClicked) {\r\n            // to make callback async, do in a timeout\r\n            setTimeout(function () { return colDef.onCellClicked(cellClickedEvent); }, 0);\r\n        }\r\n        var editOnSingleClick = this.beans.gridOptionsWrapper.isSingleClickEdit()\r\n            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\r\n        if (editOnSingleClick) {\r\n            this.startRowOrCellEdit();\r\n        }\r\n        this.doIeFocusHack();\r\n    };\r\n    // https://ag-grid.com/forum/showthread.php?tid=4362\r\n    // when in IE or Edge, when you are editing a cell, then click on another cell,\r\n    // the other cell doesn't keep focus, so navigation keys, type to start edit etc\r\n    // don't work. appears that when you update the dom in IE it looses focus\r\n    CellComp.prototype.doIeFocusHack = function () {\r\n        if (utils_1._.isBrowserIE() || utils_1._.isBrowserEdge()) {\r\n            if (utils_1._.missing(document.activeElement) || document.activeElement === document.body) {\r\n                // console.log('missing focus');\r\n                this.getGui().focus();\r\n            }\r\n        }\r\n    };\r\n    CellComp.prototype.createGridCellVo = function () {\r\n        var gridCellDef = {\r\n            rowIndex: this.rowNode.rowIndex,\r\n            floating: this.rowNode.rowPinned,\r\n            column: this.column\r\n        };\r\n        this.gridCell = new gridCell_1.GridCell(gridCellDef);\r\n    };\r\n    CellComp.prototype.getGridCell = function () {\r\n        return this.gridCell;\r\n    };\r\n    CellComp.prototype.getParentRow = function () {\r\n        return this.eParentRow;\r\n    };\r\n    CellComp.prototype.setParentRow = function (eParentRow) {\r\n        this.eParentRow = eParentRow;\r\n    };\r\n    CellComp.prototype.getColumn = function () {\r\n        return this.column;\r\n    };\r\n    CellComp.prototype.detach = function () {\r\n        this.eParentRow.removeChild(this.getGui());\r\n    };\r\n    // if the row is also getting destroyed, then we don't need to remove from dom,\r\n    // as the row will also get removed, so no need to take out the cells from the row\r\n    // if the row is going (removing is an expensive operation, so only need to remove\r\n    // the top part)\r\n    CellComp.prototype.destroy = function () {\r\n        _super.prototype.destroy.call(this);\r\n        if (this.cellEditor && this.cellEditor.destroy) {\r\n            this.cellEditor.destroy();\r\n            this.cellEditor = null;\r\n        }\r\n        if (this.cellRenderer && this.cellRenderer.destroy) {\r\n            this.cellRenderer.destroy();\r\n            this.cellRenderer = null;\r\n        }\r\n    };\r\n    CellComp.prototype.onLeftChanged = function () {\r\n        var left = this.getCellLeft();\r\n        this.getGui().style.left = left + 'px';\r\n    };\r\n    CellComp.prototype.onWidthChanged = function () {\r\n        var width = this.getCellWidth();\r\n        this.getGui().style.width = width + 'px';\r\n    };\r\n    CellComp.prototype.getRangeClasses = function () {\r\n        var res = [];\r\n        if (!this.rangeSelectionEnabled) {\r\n            return res;\r\n        }\r\n        if (this.rangeCount !== 0) {\r\n            res.push('ag-cell-range-selected');\r\n        }\r\n        if (this.rangeCount === 1) {\r\n            res.push('ag-cell-range-selected-1');\r\n        }\r\n        if (this.rangeCount === 2) {\r\n            res.push('ag-cell-range-selected-2');\r\n        }\r\n        if (this.rangeCount === 3) {\r\n            res.push('ag-cell-range-selected-3');\r\n        }\r\n        if (this.rangeCount >= 4) {\r\n            res.push('ag-cell-range-selected-4');\r\n        }\r\n        return res;\r\n    };\r\n    CellComp.prototype.onRowIndexChanged = function () {\r\n        // when index changes, this influences items that need the index, so we update the\r\n        // grid cell so they are working off the new index.\r\n        this.createGridCellVo();\r\n        // when the index of the row changes, ie means the cell may have lost or gained focus\r\n        this.onCellFocused();\r\n        // check range selection\r\n        this.onRangeSelectionChanged();\r\n    };\r\n    CellComp.prototype.onRangeSelectionChanged = function () {\r\n        if (!this.beans.enterprise) {\r\n            return;\r\n        }\r\n        var newRangeCount = this.beans.rangeController.getCellRangeCount(this.gridCell);\r\n        var element = this.getGui();\r\n        if (this.rangeCount !== newRangeCount) {\r\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\r\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\r\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\r\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\r\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\r\n            this.rangeCount = newRangeCount;\r\n        }\r\n    };\r\n    CellComp.prototype.onFirstRightPinnedChanged = function () {\r\n        var firstRightPinned = this.column.isFirstRightPinned();\r\n        if (this.firstRightPinned !== firstRightPinned) {\r\n            this.firstRightPinned = firstRightPinned;\r\n            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\r\n        }\r\n    };\r\n    CellComp.prototype.onLastLeftPinnedChanged = function () {\r\n        var lastLeftPinned = this.column.isLastLeftPinned();\r\n        if (this.lastLeftPinned !== lastLeftPinned) {\r\n            this.lastLeftPinned = lastLeftPinned;\r\n            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\r\n        }\r\n    };\r\n    CellComp.prototype.populateTemplate = function () {\r\n        if (this.usingWrapper) {\r\n            this.eParentOfValue = this.getRefElement('eCellValue');\r\n            this.eCellWrapper = this.getRefElement('eCellWrapper');\r\n            if (this.includeRowDraggingComponent) {\r\n                this.addRowDragging();\r\n            }\r\n            if (this.includeSelectionComponent) {\r\n                this.addSelectionCheckbox();\r\n            }\r\n        }\r\n        else {\r\n            this.eParentOfValue = this.getGui();\r\n        }\r\n    };\r\n    CellComp.prototype.addRowDragging = function () {\r\n        // row dragging only available in default row model\r\n        if (!this.beans.gridOptionsWrapper.isRowModelDefault()) {\r\n            utils_1._.doOnce(function () { return console.warn('ag-Grid: row dragging is only allowed in the In Memory Row Model'); }, 'CellComp.addRowDragging');\r\n            return;\r\n        }\r\n        if (this.beans.gridOptionsWrapper.isPagination()) {\r\n            utils_1._.doOnce(function () { return console.warn('ag-Grid: row dragging is not possible when doing pagination'); }, 'CellComp.addRowDragging');\r\n            return;\r\n        }\r\n        var rowDraggingComp = new rowDragComp_1.RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\r\n        this.addFeature(this.beans.context, rowDraggingComp);\r\n        // let visibleFunc = this.column.getColDef().checkboxSelection;\r\n        // visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\r\n        // cbSelectionComponent.init({rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc});\r\n        // put the checkbox in before the value\r\n        this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\r\n    };\r\n    CellComp.prototype.addSelectionCheckbox = function () {\r\n        var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();\r\n        this.beans.context.wireBean(cbSelectionComponent);\r\n        var visibleFunc = this.column.getColDef().checkboxSelection;\r\n        visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\r\n        cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc });\r\n        this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });\r\n        // put the checkbox in before the value\r\n        this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\r\n    };\r\n    CellComp.prototype.addDomData = function () {\r\n        var _this = this;\r\n        var element = this.getGui();\r\n        this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\r\n        this.addDestroyFunc(function () {\r\n            return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);\r\n        });\r\n    };\r\n    CellComp.prototype.onCellFocused = function (event) {\r\n        var cellFocused = this.beans.focusedCellController.isCellFocused(this.gridCell);\r\n        // see if we need to change the classes on this cell\r\n        if (cellFocused !== this.cellFocused) {\r\n            // if we are not doing cell selection, then the focus class does not change, all cells will\r\n            // stay with ag-cell-no-focus class\r\n            var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\r\n            if (doingFocusCss) {\r\n                utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\r\n                utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-no-focus', !cellFocused);\r\n            }\r\n            this.cellFocused = cellFocused;\r\n        }\r\n        // if this cell was just focused, see if we need to force browser focus, his can\r\n        // happen if focus is programmatically set.\r\n        if (cellFocused && event && event.forceBrowserFocus) {\r\n            this.getGui().focus();\r\n        }\r\n        // if another cell was focused, and we are editing, then stop editing\r\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\r\n        if (!cellFocused && !fullRowEdit && this.editingCell) {\r\n            this.stopRowOrCellEdit();\r\n        }\r\n    };\r\n    // pass in 'true' to cancel the editing.\r\n    CellComp.prototype.stopRowOrCellEdit = function (cancel) {\r\n        if (cancel === void 0) {\r\n            cancel = false;\r\n        }\r\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\r\n            this.rowComp.stopRowEditing(cancel);\r\n        }\r\n        else {\r\n            this.stopEditing(cancel);\r\n        }\r\n    };\r\n    CellComp.prototype.stopEditing = function (cancel) {\r\n        if (cancel === void 0) {\r\n            cancel = false;\r\n        }\r\n        if (!this.editingCell) {\r\n            return;\r\n        }\r\n        // if no cell editor, this means due to async, that the cell editor never got initialised,\r\n        // so we just carry on regardless as if the editing was never started.\r\n        if (!this.cellEditor) {\r\n            this.editingCell = false;\r\n            return;\r\n        }\r\n        var newValueExists = false;\r\n        var newValue;\r\n        if (!cancel) {\r\n            // also have another option here to cancel after editing, so for example user could have a popup editor and\r\n            // it is closed by user clicking outside the editor. then the editor will close automatically (with false\r\n            // passed above) and we need to see if the editor wants to accept the new value.\r\n            var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\r\n            if (!userWantsToCancel) {\r\n                newValue = this.cellEditor.getValue();\r\n                newValueExists = true;\r\n            }\r\n        }\r\n        // it is important we set this after setValue() above, as otherwise the cell will flash\r\n        // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\r\n        // thus it will skip the refresh on this cell until the end of this method where we call\r\n        // refresh directly and we suppress the flash.\r\n        this.editingCell = false;\r\n        if (this.cellEditor.destroy) {\r\n            this.cellEditor.destroy();\r\n        }\r\n        // important to clear this out - as parts of the code will check for\r\n        // this to see if an async cellEditor has yet to be created\r\n        this.cellEditor = null;\r\n        if (this.cellEditorInPopup) {\r\n            this.hideEditorPopup();\r\n            this.hideEditorPopup = null;\r\n        }\r\n        else {\r\n            utils_1._.removeAllChildren(this.getGui());\r\n            // put the cell back the way it was before editing\r\n            if (this.usingWrapper) {\r\n                // if wrapper, then put the wrapper back\r\n                this.getGui().appendChild(this.eCellWrapper);\r\n            }\r\n            else {\r\n                // if cellRenderer, then put the gui back in. if the renderer has\r\n                // a refresh, it will be called. however if it doesn't, then later\r\n                // the renderer will be destroyed and a new one will be created.\r\n                if (this.cellRenderer) {\r\n                    // we know it's a dom element (not a string) because we converted\r\n                    // it after the gui was attached if it was a string.\r\n                    var eCell = this.cellRendererGui;\r\n                    // can be null if cell was previously null / contained empty string,\r\n                    // this will result in new value not being rendered.\r\n                    if (eCell) {\r\n                        this.getGui().appendChild(eCell);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.setInlineEditingClass();\r\n        if (newValueExists) {\r\n            this.rowNode.setDataValue(this.column, newValue);\r\n            this.getValueAndFormat();\r\n        }\r\n        // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\r\n        // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\r\n        // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\r\n        this.refreshCell({ forceRefresh: true, suppressFlash: true });\r\n        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STOPPED);\r\n        this.beans.eventService.dispatchEvent(event);\r\n    };\r\n    CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\r\n    return CellComp;\r\n}(component_1.Component));\r\nexports.CellComp = CellComp;\r\n",null]}