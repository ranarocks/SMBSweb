{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\inMemory\\inMemoryNodeManager.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\rowModels\\inMemory\\inMemoryNodeManager.js","mtime":1525243700181},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\r\n * @version v17.1.1\r\n * @link http://www.ag-grid.com/\r\n * @license MIT\r\n */\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar rowNode_1 = require(\"../../entities/rowNode\");\r\nvar utils_1 = require(\"../../utils\");\r\nvar InMemoryNodeManager = /*@__PURE__*/ (function () {\r\n    function InMemoryNodeManager(rootNode, gridOptionsWrapper, context, eventService, columnController) {\r\n        this.nextId = 0;\r\n        // when user is provide the id's, we also keep a map of ids to row nodes for convenience\r\n        this.allNodesMap = {};\r\n        this.rootNode = rootNode;\r\n        this.gridOptionsWrapper = gridOptionsWrapper;\r\n        this.context = context;\r\n        this.eventService = eventService;\r\n        this.columnController = columnController;\r\n        this.rootNode.group = true;\r\n        this.rootNode.level = -1;\r\n        this.rootNode.id = InMemoryNodeManager.ROOT_NODE_ID;\r\n        this.rootNode.allLeafChildren = [];\r\n        this.rootNode.childrenAfterGroup = [];\r\n        this.rootNode.childrenAfterSort = [];\r\n        this.rootNode.childrenAfterFilter = [];\r\n        // if we make this class a bean, then can annotate postConstruct\r\n        this.postConstruct();\r\n    }\r\n    // @PostConstruct - this is not a bean, so postConstruct called by constructor\r\n    InMemoryNodeManager.prototype.postConstruct = function () {\r\n        // func below doesn't have 'this' pointer, so need to pull out these bits\r\n        this.getNodeChildDetails = this.gridOptionsWrapper.getNodeChildDetailsFunc();\r\n        this.suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();\r\n        this.doesDataFlower = this.gridOptionsWrapper.getDoesDataFlowerFunc();\r\n        this.isRowMasterFunc = this.gridOptionsWrapper.getIsRowMasterFunc();\r\n        this.doingLegacyTreeData = utils_1.Utils.exists(this.getNodeChildDetails);\r\n        this.doingMasterDetail = this.gridOptionsWrapper.isMasterDetail();\r\n    };\r\n    InMemoryNodeManager.prototype.getCopyOfNodesMap = function () {\r\n        var result = utils_1.Utils.cloneObject(this.allNodesMap);\r\n        return result;\r\n    };\r\n    InMemoryNodeManager.prototype.getRowNode = function (id) {\r\n        return this.allNodesMap[id];\r\n    };\r\n    InMemoryNodeManager.prototype.setRowData = function (rowData) {\r\n        this.rootNode.childrenAfterFilter = null;\r\n        this.rootNode.childrenAfterGroup = null;\r\n        this.rootNode.childrenAfterSort = null;\r\n        this.rootNode.childrenMapped = null;\r\n        this.nextId = 0;\r\n        this.allNodesMap = {};\r\n        if (!rowData) {\r\n            this.rootNode.allLeafChildren = [];\r\n            this.rootNode.childrenAfterGroup = [];\r\n            return;\r\n        }\r\n        // kick off recursion\r\n        var result = this.recursiveFunction(rowData, null, InMemoryNodeManager.TOP_LEVEL);\r\n        if (this.doingLegacyTreeData) {\r\n            this.rootNode.childrenAfterGroup = result;\r\n            this.setLeafChildren(this.rootNode);\r\n        }\r\n        else {\r\n            this.rootNode.allLeafChildren = result;\r\n        }\r\n    };\r\n    InMemoryNodeManager.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\r\n        var _this = this;\r\n        if (this.isLegacyTreeData()) {\r\n            return null;\r\n        }\r\n        var add = rowDataTran.add, addIndex = rowDataTran.addIndex, remove = rowDataTran.remove, update = rowDataTran.update;\r\n        var rowNodeTransaction = {\r\n            remove: [],\r\n            update: [],\r\n            add: []\r\n        };\r\n        if (utils_1.Utils.exists(add)) {\r\n            var useIndex = typeof addIndex === 'number' && addIndex >= 0;\r\n            if (useIndex) {\r\n                // items get inserted in reverse order for index insertion\r\n                add.reverse().forEach(function (item) {\r\n                    var newRowNode = _this.addRowNode(item, addIndex);\r\n                    rowNodeTransaction.add.push(newRowNode);\r\n                });\r\n            }\r\n            else {\r\n                add.forEach(function (item) {\r\n                    var newRowNode = _this.addRowNode(item);\r\n                    rowNodeTransaction.add.push(newRowNode);\r\n                });\r\n            }\r\n        }\r\n        if (utils_1.Utils.exists(remove)) {\r\n            remove.forEach(function (item) {\r\n                var removedRowNode = _this.updatedRowNode(item, false);\r\n                if (removedRowNode) {\r\n                    rowNodeTransaction.remove.push(removedRowNode);\r\n                }\r\n            });\r\n        }\r\n        if (utils_1.Utils.exists(update)) {\r\n            update.forEach(function (item) {\r\n                var updatedRowNode = _this.updatedRowNode(item, true);\r\n                if (updatedRowNode) {\r\n                    rowNodeTransaction.update.push(updatedRowNode);\r\n                }\r\n            });\r\n        }\r\n        if (rowNodeOrder) {\r\n            utils_1.Utils.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);\r\n        }\r\n        return rowNodeTransaction;\r\n    };\r\n    InMemoryNodeManager.prototype.addRowNode = function (data, index) {\r\n        var newNode = this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);\r\n        if (utils_1.Utils.exists(index)) {\r\n            utils_1.Utils.insertIntoArray(this.rootNode.allLeafChildren, newNode, index);\r\n        }\r\n        else {\r\n            this.rootNode.allLeafChildren.push(newNode);\r\n        }\r\n        return newNode;\r\n    };\r\n    InMemoryNodeManager.prototype.updatedRowNode = function (data, update) {\r\n        var rowNodeIdFunc = this.gridOptionsWrapper.getRowNodeIdFunc();\r\n        var rowNode;\r\n        if (utils_1.Utils.exists(rowNodeIdFunc)) {\r\n            // find rowNode using id\r\n            var id = rowNodeIdFunc(data);\r\n            rowNode = this.allNodesMap[id];\r\n            if (!rowNode) {\r\n                console.error(\"ag-Grid: could not find row id=\" + id + \", data item was not found for this id\");\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            // find rowNode using object references\r\n            rowNode = utils_1.Utils.find(this.rootNode.allLeafChildren, function (rowNode) { return rowNode.data === data; });\r\n            if (!rowNode) {\r\n                console.error(\"ag-Grid: could not find data item as object was not found\", data);\r\n                return null;\r\n            }\r\n        }\r\n        if (update) {\r\n            // do update\r\n            rowNode.updateData(data);\r\n        }\r\n        else {\r\n            // do delete\r\n            rowNode.setSelected(false);\r\n            // so row renderer knows to fade row out (and not reposition it)\r\n            rowNode.clearRowTop();\r\n            utils_1.Utils.removeFromArray(this.rootNode.allLeafChildren, rowNode);\r\n            this.allNodesMap[rowNode.id] = undefined;\r\n        }\r\n        return rowNode;\r\n    };\r\n    InMemoryNodeManager.prototype.recursiveFunction = function (rowData, parent, level) {\r\n        var _this = this;\r\n        // make sure the rowData is an array and not a string of json - this was a commonly reported problem on the forum\r\n        if (typeof rowData === 'string') {\r\n            console.warn('ag-Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');\r\n            return;\r\n        }\r\n        var rowNodes = [];\r\n        rowData.forEach(function (dataItem) {\r\n            var node = _this.createNode(dataItem, parent, level);\r\n            rowNodes.push(node);\r\n        });\r\n        return rowNodes;\r\n    };\r\n    InMemoryNodeManager.prototype.createNode = function (dataItem, parent, level) {\r\n        var node = new rowNode_1.RowNode();\r\n        this.context.wireBean(node);\r\n        var doingTreeData = this.gridOptionsWrapper.isTreeData();\r\n        var doingLegacyTreeData = !doingTreeData && utils_1.Utils.exists(this.getNodeChildDetails);\r\n        var nodeChildDetails = doingLegacyTreeData ? this.getNodeChildDetails(dataItem) : null;\r\n        if (nodeChildDetails && nodeChildDetails.group) {\r\n            node.group = true;\r\n            node.childrenAfterGroup = this.recursiveFunction(nodeChildDetails.children, node, level + 1);\r\n            node.expanded = nodeChildDetails.expanded === true;\r\n            node.field = nodeChildDetails.field;\r\n            node.key = nodeChildDetails.key;\r\n            node.canFlower = node.master; // deprecated, is now 'master'\r\n            // pull out all the leaf children and add to our node\r\n            this.setLeafChildren(node);\r\n        }\r\n        else {\r\n            node.group = false;\r\n            if (doingTreeData) {\r\n                node.master = false;\r\n                node.expanded = false;\r\n            }\r\n            else {\r\n                // this is the default, for when doing grid data\r\n                if (this.doesDataFlower) {\r\n                    node.master = this.doesDataFlower(dataItem);\r\n                }\r\n                else if (this.doingMasterDetail) {\r\n                    // if we are doing master detail, then the\r\n                    // default is that everything can flower.\r\n                    if (this.isRowMasterFunc) {\r\n                        node.master = this.isRowMasterFunc(dataItem);\r\n                    }\r\n                    else {\r\n                        node.master = true;\r\n                    }\r\n                }\r\n                else {\r\n                    node.master = false;\r\n                }\r\n                var rowGroupColumns = this.columnController.getRowGroupColumns();\r\n                var numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\r\n                // need to take row group into account when determining level\r\n                var masterRowLevel = level + numRowGroupColumns;\r\n                node.expanded = node.master ? this.isExpanded(masterRowLevel) : false;\r\n            }\r\n        }\r\n        // support for backwards compatibility, canFlow is now called 'master'\r\n        node.canFlower = node.master;\r\n        if (parent && !this.suppressParentsInRowNodes) {\r\n            node.parent = parent;\r\n        }\r\n        node.level = level;\r\n        node.setDataAndId(dataItem, this.nextId.toString());\r\n        this.allNodesMap[node.id] = node;\r\n        this.nextId++;\r\n        return node;\r\n    };\r\n    InMemoryNodeManager.prototype.isExpanded = function (level) {\r\n        var expandByDefault = this.gridOptionsWrapper.getGroupDefaultExpanded();\r\n        if (expandByDefault === -1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return level < expandByDefault;\r\n        }\r\n    };\r\n    // this is only used for doing legacy tree data\r\n    InMemoryNodeManager.prototype.setLeafChildren = function (node) {\r\n        node.allLeafChildren = [];\r\n        if (node.childrenAfterGroup) {\r\n            node.childrenAfterGroup.forEach(function (childAfterGroup) {\r\n                if (childAfterGroup.group) {\r\n                    if (childAfterGroup.allLeafChildren) {\r\n                        childAfterGroup.allLeafChildren.forEach(function (leafChild) { return node.allLeafChildren.push(leafChild); });\r\n                    }\r\n                }\r\n                else {\r\n                    node.allLeafChildren.push(childAfterGroup);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    InMemoryNodeManager.prototype.insertItemsAtIndex = function (index, rowData) {\r\n        if (this.isLegacyTreeData()) {\r\n            return null;\r\n        }\r\n        var nodeList = this.rootNode.allLeafChildren;\r\n        if (index > nodeList.length) {\r\n            console.warn(\"ag-Grid: invalid index \" + index + \", max index is \" + nodeList.length);\r\n            return;\r\n        }\r\n        var newNodes = [];\r\n        // go through the items backwards, otherwise they get added in reverse order\r\n        for (var i = rowData.length - 1; i >= 0; i--) {\r\n            var data = rowData[i];\r\n            var newNode = this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);\r\n            utils_1.Utils.insertIntoArray(nodeList, newNode, index);\r\n            newNodes.push(newNode);\r\n        }\r\n        return newNodes.length > 0 ? newNodes : null;\r\n    };\r\n    InMemoryNodeManager.prototype.addItems = function (items) {\r\n        var nodeList = this.rootNode.allLeafChildren;\r\n        return this.insertItemsAtIndex(nodeList.length, items);\r\n    };\r\n    InMemoryNodeManager.prototype.isLegacyTreeData = function () {\r\n        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\r\n        if (rowsAlreadyGrouped) {\r\n            console.warn('ag-Grid: adding and removing rows is not supported when using nodeChildDetailsFunc, ie it is not ' +\r\n                'supported for legacy tree data. Please see the docs on the new preferred way of providing tree data that works with delta updates.');\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    InMemoryNodeManager.TOP_LEVEL = 0;\r\n    InMemoryNodeManager.ROOT_NODE_ID = 'ROOT_NODE_ID';\r\n    return InMemoryNodeManager;\r\n}());\r\nexports.InMemoryNodeManager = InMemoryNodeManager;\r\n",null]}