{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\headerRendering\\moveColumnController.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\headerRendering\\moveColumnController.js","mtime":1525243698870},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v17.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"../context/context\");\nvar logger_1 = require(\"../logger\");\nvar columnController_1 = require(\"../columnController/columnController\");\nvar column_1 = require(\"../entities/column\");\nvar utils_1 = require(\"../utils\");\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\nvar gridPanel_1 = require(\"../gridPanel/gridPanel\");\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar MoveColumnController = /*@__PURE__*/ (function () {\n    function MoveColumnController(pinned, eContainer) {\n        this.needToMoveLeft = false;\n        this.needToMoveRight = false;\n        this.pinned = pinned;\n        this.eContainer = eContainer;\n        this.centerContainer = !utils_1.Utils.exists(pinned);\n    }\n    MoveColumnController.prototype.init = function () {\n        this.logger = this.loggerFactory.create('MoveColumnController');\n    };\n    MoveColumnController.prototype.getIconName = function () {\n        return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;\n    };\n    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {\n        // we do dummy drag, so make sure column appears in the right location when first placed\n        var columns = draggingEvent.dragItem.columns;\n        var dragCameFromToolPanel = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;\n        if (dragCameFromToolPanel) {\n            // the if statement doesn't work if drag leaves grid, then enters again\n            this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n        }\n        else {\n            // restore previous state of visible columns upon re-entering. this means if the user drags\n            // a group out, and then drags the group back in, only columns that were originally visible\n            // will be visible again. otherwise a group with three columns (but only two visible) could\n            // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n            var visibleState_1 = draggingEvent.dragItem.visibleState;\n            var visibleColumns = columns.filter(function (column) { return visibleState_1[column.getId()]; });\n            this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n        }\n        this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n        this.onDragging(draggingEvent, true);\n    };\n    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {\n        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n        if (hideColumnOnExit) {\n            var dragItem = draggingEvent.dragSource.dragItemCallback();\n            var columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.setColumnsVisible = function (columns, visible, source) {\n        if (source === void 0) {\n            source = \"api\";\n        }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.isLockVisible(); });\n            this.columnController.setColumnsVisible(allowedCols, visible, source);\n        }\n    };\n    MoveColumnController.prototype.setColumnsPinned = function (columns, pinned, source) {\n        if (source === void 0) {\n            source = \"api\";\n        }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.isLockPinned(); });\n            this.columnController.setColumnsPinned(allowedCols, pinned, source);\n        }\n    };\n    MoveColumnController.prototype.onDragStop = function () {\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.normaliseX = function (x) {\n        // flip the coordinate if doing RTL\n        var flipHorizontallyForRtl = this.gridOptionsWrapper.isEnableRtl();\n        if (flipHorizontallyForRtl) {\n            var clientWidth = this.eContainer.clientWidth;\n            x = clientWidth - x;\n        }\n        // adjust for scroll only if centre container (the pinned containers dont scroll)\n        var adjustForScroll = this.centerContainer;\n        if (adjustForScroll) {\n            x += this.gridPanel.getBodyViewportScrollLeft();\n        }\n        return x;\n    };\n    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n        if (this.centerContainer) {\n            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n            var firstVisiblePixel = this.gridPanel.getBodyViewportScrollLeft();\n            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            else {\n                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            if (this.needToMoveLeft || this.needToMoveRight) {\n                this.ensureIntervalStarted();\n            }\n            else {\n                this.ensureIntervalCleared();\n            }\n        }\n    };\n    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {\n        var _this = this;\n        if (fromEnter === void 0) {\n            fromEnter = false;\n        }\n        this.lastDraggingEvent = draggingEvent;\n        // if moving up or down (ie not left or right) then do nothing\n        if (utils_1.Utils.missing(draggingEvent.hDirection)) {\n            return;\n        }\n        var xNormalised = this.normaliseX(draggingEvent.x);\n        // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n        // we don't want to scroll the grid this time, it would appear like the table is jumping\n        // each time a column is dragged in.\n        if (!fromEnter) {\n            this.checkCenterForScrolling(xNormalised);\n        }\n        var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n        var dragSourceType = draggingEvent.dragSource.type;\n        var columnsToMove = draggingEvent.dragSource.dragItemCallback().columns;\n        columnsToMove = columnsToMove.filter(function (col) {\n            if (col.isLockPinned()) {\n                // if locked return true only if both col and container are same pin type.\n                // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n                return col.getPinned() == _this.pinned;\n            }\n            else {\n                // if not pin locked, then always allowed to be in this container\n                return true;\n            }\n        });\n        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, xNormalised, fromEnter);\n    };\n    MoveColumnController.prototype.normaliseDirection = function (hDirection) {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            switch (hDirection) {\n                case dragAndDropService_1.HDirection.Left: return dragAndDropService_1.HDirection.Right;\n                case dragAndDropService_1.HDirection.Right: return dragAndDropService_1.HDirection.Left;\n                default: console.error(\"ag-Grid: Unknown direction \" + hDirection);\n            }\n        }\n        else {\n            return hDirection;\n        }\n    };\n    // returns the index of the first column in the list ONLY if the cols are all beside\n    // each other. if the cols are not beside each other, then returns null\n    MoveColumnController.prototype.calculateOldIndex = function (movingCols) {\n        var gridCols = this.columnController.getAllGridColumns();\n        var indexes = [];\n        movingCols.forEach(function (col) { return indexes.push(gridCols.indexOf(col)); });\n        utils_1.Utils.sortNumberArray(indexes);\n        var firstIndex = indexes[0];\n        var lastIndex = indexes[indexes.length - 1];\n        var spread = lastIndex - firstIndex;\n        var gapsExist = spread !== indexes.length - 1;\n        return gapsExist ? null : firstIndex;\n    };\n    MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, xAdjusted, fromEnter) {\n        var draggingLeft = hDirection === dragAndDropService_1.HDirection.Left;\n        var draggingRight = hDirection === dragAndDropService_1.HDirection.Right;\n        var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, xAdjusted);\n        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n        // (ie left or right) to the mouse direction. however\n        var oldIndex = this.calculateOldIndex(allMovingColumns);\n        // fromEnter = false;\n        for (var i = 0; i < validMoves.length; i++) {\n            var newIndex = validMoves[i];\n            // the two check below stop an error when the user grabs a group my a middle column, then\n            // it is possible the mouse pointer is to the right of a column while been dragged left.\n            // so we need to make sure that the mouse pointer is actually left of the left most column\n            // if moving left, and right of the right most column if moving right\n            // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n            // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n            // place the column to the RHS even if the mouse is moving left and the column is already on\n            // the LHS. otherwise we stick to the rule described above.\n            var constrainDirection = oldIndex !== null && !fromEnter;\n            // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n            if (dragSourceType == dragAndDropService_1.DragSourceType.HeaderCell) {\n                constrainDirection = oldIndex !== null;\n            }\n            if (constrainDirection) {\n                // only allow left drag if this column is moving left\n                if (draggingLeft && newIndex >= oldIndex) {\n                    continue;\n                }\n                // only allow right drag if this column is moving right\n                if (draggingRight && newIndex <= oldIndex) {\n                    continue;\n                }\n            }\n            if (!this.columnController.doesMovePassRules(allMovingColumns, newIndex)) {\n                continue;\n            }\n            this.columnController.moveColumns(allMovingColumns, newIndex, \"uiColumnDragged\");\n            // important to return here, so once we do the first valid move, we don't try do any more\n            return;\n        }\n    };\n    MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, x) {\n        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n        var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned);\n        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n        // so the result we return has to be and index location for this list\n        var allGridCols = this.columnController.getAllGridColumns();\n        var colIsMovingFunc = function (col) { return movingCols.indexOf(col) >= 0; };\n        var colIsNotMovingFunc = function (col) { return movingCols.indexOf(col) < 0; };\n        var movingDisplayedCols = allDisplayedCols.filter(colIsMovingFunc);\n        var otherDisplayedCols = allDisplayedCols.filter(colIsNotMovingFunc);\n        var otherGridCols = allGridCols.filter(colIsNotMovingFunc);\n        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n        // col between b and c (so that it is under the mouse position).\n        var displayIndex = 0;\n        var availableWidth = x;\n        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n        // include the width of the moving columns\n        if (draggingRight) {\n            var widthOfMovingDisplayedCols_1 = 0;\n            movingDisplayedCols.forEach(function (col) { return widthOfMovingDisplayedCols_1 += col.getActualWidth(); });\n            availableWidth -= widthOfMovingDisplayedCols_1;\n        }\n        // now count how many of the displayed columns will fit to the left\n        for (var i = 0; i < otherDisplayedCols.length; i++) {\n            var col = otherDisplayedCols[i];\n            availableWidth -= col.getActualWidth();\n            if (availableWidth < 0) {\n                break;\n            }\n            displayIndex++;\n        }\n        // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n        if (draggingRight) {\n            displayIndex++;\n        }\n        // the display index is with respect to all the showing columns, however when we move, it's with\n        // respect to all grid columns, so we need to translate from display index to grid index\n        var gridColIndex;\n        if (displayIndex > 0) {\n            var leftColumn = otherDisplayedCols[displayIndex - 1];\n            gridColIndex = otherGridCols.indexOf(leftColumn) + 1;\n        }\n        else {\n            gridColIndex = 0;\n        }\n        var validMoves = [gridColIndex];\n        // add in all adjacent empty columns as other valid moves. this allows us to try putting the new\n        // column in any place of a hidden column, to try different combinations so that we don't break\n        // married children. in other words, maybe the new index breaks a group, but only because some\n        // columns are hidden, maybe we can reshuffle the hidden columns to find a place that works.\n        var nextCol = allGridCols[gridColIndex];\n        while (utils_1.Utils.exists(nextCol) && this.isColumnHidden(allDisplayedCols, nextCol)) {\n            gridColIndex++;\n            validMoves.push(gridColIndex);\n            nextCol = allGridCols[gridColIndex];\n        }\n        return validMoves;\n    };\n    // isHidden takes into account visible=false and group=closed, ie it is not displayed\n    MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {\n        return displayedColumns.indexOf(col) < 0;\n    };\n    MoveColumnController.prototype.ensureIntervalStarted = function () {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.failedMoveAttempts = 0;\n            this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);\n            if (this.needToMoveLeft) {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);\n            }\n            else {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);\n            }\n        }\n    };\n    MoveColumnController.prototype.ensureIntervalCleared = function () {\n        if (this.moveInterval) {\n            clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);\n        }\n    };\n    MoveColumnController.prototype.moveInterval = function () {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        var pixelsToMove;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n        var pixelsMoved;\n        if (this.needToMoveLeft) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);\n        }\n        else if (this.needToMoveRight) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);\n        }\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n            this.failedMoveAttempts = 0;\n        }\n        else {\n            // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n            // this is how we achieve pining by dragging the column to the edge of the grid.\n            this.failedMoveAttempts++;\n            var columns = this.lastDraggingEvent.dragItem.columns;\n            var columnsThatCanPin = columns.filter(function (c) { return !c.isLockPinned(); });\n            if (columnsThatCanPin.length > 0) {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);\n                if (this.failedMoveAttempts > 7) {\n                    var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;\n                    this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n                    this.dragAndDropService.nudge();\n                }\n            }\n        }\n    };\n    __decorate([\n        context_1.Autowired('loggerFactory'),\n        __metadata(\"design:type\", logger_1.LoggerFactory)\n    ], MoveColumnController.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], MoveColumnController.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('gridPanel'),\n        __metadata(\"design:type\", gridPanel_1.GridPanel)\n    ], MoveColumnController.prototype, \"gridPanel\", void 0);\n    __decorate([\n        context_1.Autowired('dragAndDropService'),\n        __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)\n    ], MoveColumnController.prototype, \"dragAndDropService\", void 0);\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], MoveColumnController.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], MoveColumnController.prototype, \"init\", null);\n    return MoveColumnController;\n}());\nexports.MoveColumnController = MoveColumnController;\n",null]}