{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\cellNavigationService.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\cellNavigationService.js","mtime":1525243698401},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v17.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"./context/context\");\nvar constants_1 = require(\"./constants\");\nvar columnController_1 = require(\"./columnController/columnController\");\nvar utils_1 = require(\"./utils\");\nvar gridRow_1 = require(\"./entities/gridRow\");\nvar gridCell_1 = require(\"./entities/gridCell\");\nvar gridOptionsWrapper_1 = require(\"./gridOptionsWrapper\");\nvar pinnedRowModel_1 = require(\"./rowModels/pinnedRowModel\");\nvar CellNavigationService = /*@__PURE__*/ (function () {\n    function CellNavigationService() {\n    }\n    // returns null if no cell to focus on, ie at the end of the grid\n    CellNavigationService.prototype.getNextCellToFocus = function (key, lastCellToFocus) {\n        // starting with the provided cell, we keep moving until we find a cell we can\n        // focus on.\n        var pointer = lastCellToFocus;\n        var finished = false;\n        // finished will be true when either:\n        // a) cell found that we can focus on\n        // b) run out of cells (ie the method returns null)\n        while (!finished) {\n            switch (key) {\n                case constants_1.Constants.KEY_UP:\n                    pointer = this.getCellAbove(pointer);\n                    break;\n                case constants_1.Constants.KEY_DOWN:\n                    pointer = this.getCellBelow(pointer);\n                    break;\n                case constants_1.Constants.KEY_RIGHT:\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToLeft(pointer);\n                    }\n                    else {\n                        pointer = this.getCellToRight(pointer);\n                    }\n                    break;\n                case constants_1.Constants.KEY_LEFT:\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToRight(pointer);\n                    }\n                    else {\n                        pointer = this.getCellToLeft(pointer);\n                    }\n                    break;\n                default:\n                    console.log('ag-Grid: unknown key for navigation ' + key);\n                    pointer = null;\n                    break;\n            }\n            if (pointer) {\n                finished = this.isCellGoodToFocusOn(pointer);\n            }\n            else {\n                finished = true;\n            }\n        }\n        return pointer;\n    };\n    CellNavigationService.prototype.isCellGoodToFocusOn = function (gridCell) {\n        var column = gridCell.column;\n        var rowNode;\n        switch (gridCell.floating) {\n            case constants_1.Constants.PINNED_TOP:\n                rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);\n                break;\n            case constants_1.Constants.PINNED_BOTTOM:\n                rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);\n                break;\n            default:\n                rowNode = this.rowModel.getRow(gridCell.rowIndex);\n                break;\n        }\n        var suppressNavigable = column.isSuppressNavigable(rowNode);\n        return !suppressNavigable;\n    };\n    CellNavigationService.prototype.getCellToLeft = function (lastCell) {\n        var colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);\n        if (!colToLeft) {\n            return null;\n        }\n        else {\n            var gridCellDef = { rowIndex: lastCell.rowIndex, column: colToLeft, floating: lastCell.floating };\n            return new gridCell_1.GridCell(gridCellDef);\n        }\n    };\n    CellNavigationService.prototype.getCellToRight = function (lastCell) {\n        var colToRight = this.columnController.getDisplayedColAfter(lastCell.column);\n        // if already on right, do nothing\n        if (!colToRight) {\n            return null;\n        }\n        else {\n            var gridCellDef = { rowIndex: lastCell.rowIndex, column: colToRight, floating: lastCell.floating };\n            return new gridCell_1.GridCell(gridCellDef);\n        }\n    };\n    CellNavigationService.prototype.getRowBelow = function (lastRow) {\n        // if already on top row, do nothing\n        if (this.isLastRowInContainer(lastRow)) {\n            if (lastRow.isFloatingBottom()) {\n                return null;\n            }\n            else if (lastRow.isNotFloating()) {\n                if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_BOTTOM)) {\n                    return new gridRow_1.GridRow(0, constants_1.Constants.PINNED_BOTTOM);\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                if (this.rowModel.isRowsToRender()) {\n                    return new gridRow_1.GridRow(0, null);\n                }\n                else if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_BOTTOM)) {\n                    return new gridRow_1.GridRow(0, constants_1.Constants.PINNED_BOTTOM);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        else {\n            return new gridRow_1.GridRow(lastRow.rowIndex + 1, lastRow.floating);\n        }\n    };\n    CellNavigationService.prototype.getCellBelow = function (lastCell) {\n        var rowBelow = this.getRowBelow(lastCell.getGridRow());\n        if (rowBelow) {\n            var gridCellDef = { rowIndex: rowBelow.rowIndex, column: lastCell.column, floating: rowBelow.floating };\n            return new gridCell_1.GridCell(gridCellDef);\n        }\n        else {\n            return null;\n        }\n    };\n    CellNavigationService.prototype.isLastRowInContainer = function (gridRow) {\n        if (gridRow.isFloatingTop()) {\n            var lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n            return lastTopIndex <= gridRow.rowIndex;\n        }\n        else if (gridRow.isFloatingBottom()) {\n            var lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;\n            return lastBottomIndex <= gridRow.rowIndex;\n        }\n        else {\n            var lastBodyIndex = this.rowModel.getPageLastRow();\n            return lastBodyIndex <= gridRow.rowIndex;\n        }\n    };\n    CellNavigationService.prototype.getRowAbove = function (lastRow) {\n        // if already on top row, do nothing\n        if (lastRow.rowIndex === 0) {\n            if (lastRow.isFloatingTop()) {\n                return null;\n            }\n            else if (lastRow.isNotFloating()) {\n                if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_TOP)) {\n                    return this.getLastFloatingTopRow();\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                // last floating bottom\n                if (this.rowModel.isRowsToRender()) {\n                    return this.getLastBodyCell();\n                }\n                else if (this.pinnedRowModel.isRowsToRender(constants_1.Constants.PINNED_TOP)) {\n                    return this.getLastFloatingTopRow();\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        else {\n            return new gridRow_1.GridRow(lastRow.rowIndex - 1, lastRow.floating);\n        }\n    };\n    CellNavigationService.prototype.getCellAbove = function (lastCell) {\n        var rowAbove = this.getRowAbove(lastCell.getGridRow());\n        if (rowAbove) {\n            var gridCellDef = { rowIndex: rowAbove.rowIndex, column: lastCell.column, floating: rowAbove.floating };\n            return new gridCell_1.GridCell(gridCellDef);\n        }\n        else {\n            return null;\n        }\n    };\n    CellNavigationService.prototype.getLastBodyCell = function () {\n        var lastBodyRow = this.rowModel.getPageLastRow();\n        return new gridRow_1.GridRow(lastBodyRow, null);\n    };\n    CellNavigationService.prototype.getLastFloatingTopRow = function () {\n        var lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n        return new gridRow_1.GridRow(lastFloatingRow, constants_1.Constants.PINNED_TOP);\n    };\n    CellNavigationService.prototype.getNextTabbedCell = function (gridCell, backwards) {\n        if (backwards) {\n            return this.getNextTabbedCellBackwards(gridCell);\n        }\n        else {\n            return this.getNextTabbedCellForwards(gridCell);\n        }\n    };\n    CellNavigationService.prototype.getNextTabbedCellForwards = function (gridCell) {\n        var displayedColumns = this.columnController.getAllDisplayedColumns();\n        var newRowIndex = gridCell.rowIndex;\n        var newFloating = gridCell.floating;\n        // move along to the next cell\n        var newColumn = this.columnController.getDisplayedColAfter(gridCell.column);\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = displayedColumns[0];\n            var rowBelow = this.getRowBelow(gridCell.getGridRow());\n            if (utils_1.Utils.missing(rowBelow)) {\n                return;\n            }\n            newRowIndex = rowBelow.rowIndex;\n            newFloating = rowBelow.floating;\n        }\n        var gridCellDef = { rowIndex: newRowIndex, column: newColumn, floating: newFloating };\n        return new gridCell_1.GridCell(gridCellDef);\n    };\n    CellNavigationService.prototype.getNextTabbedCellBackwards = function (gridCell) {\n        var displayedColumns = this.columnController.getAllDisplayedColumns();\n        var newRowIndex = gridCell.rowIndex;\n        var newFloating = gridCell.floating;\n        // move along to the next cell\n        var newColumn = this.columnController.getDisplayedColBefore(gridCell.column);\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = displayedColumns[displayedColumns.length - 1];\n            var rowAbove = this.getRowAbove(gridCell.getGridRow());\n            if (utils_1.Utils.missing(rowAbove)) {\n                return;\n            }\n            newRowIndex = rowAbove.rowIndex;\n            newFloating = rowAbove.floating;\n        }\n        var gridCellDef = { rowIndex: newRowIndex, column: newColumn, floating: newFloating };\n        return new gridCell_1.GridCell(gridCellDef);\n    };\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], CellNavigationService.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('rowModel'),\n        __metadata(\"design:type\", Object)\n    ], CellNavigationService.prototype, \"rowModel\", void 0);\n    __decorate([\n        context_1.Autowired('pinnedRowModel'),\n        __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)\n    ], CellNavigationService.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], CellNavigationService.prototype, \"gridOptionsWrapper\", void 0);\n    CellNavigationService = __decorate([\n        context_1.Bean('cellNavigationService')\n    ], CellNavigationService);\n    return CellNavigationService;\n}());\nexports.CellNavigationService = CellNavigationService;\n",null]}