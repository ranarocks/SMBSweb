{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\gridPanel\\navigationService.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\gridPanel\\navigationService.js","mtime":1525243698689},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v17.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"../context/context\");\nvar gridCell_1 = require(\"../entities/gridCell\");\nvar constants_1 = require(\"../constants\");\nvar mouseEventService_1 = require(\"./mouseEventService\");\nvar paginationProxy_1 = require(\"../rowModels/paginationProxy\");\nvar focusedCellController_1 = require(\"../focusedCellController\");\nvar utils_1 = require(\"../utils\");\nvar gridPanel_1 = require(\"./gridPanel\");\nvar animationFrameService_1 = require(\"../misc/animationFrameService\");\nvar columnController_1 = require(\"../columnController/columnController\");\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar NavigationService = /*@__PURE__*/ (function () {\n    function NavigationService() {\n    }\n    NavigationService.prototype.init = function () {\n        this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();\n    };\n    NavigationService.prototype.handlePageScrollingKey = function (event) {\n        var key = event.which || event.keyCode;\n        var alt = event.altKey;\n        var ctrl = event.ctrlKey;\n        var currentCell = this.mouseEventService.getGridCellForEvent(event).getGridCellDef();\n        if (!currentCell) {\n            return false;\n        }\n        var processed = false;\n        switch (key) {\n            case constants_1.Constants.KEY_PAGE_HOME:\n            case constants_1.Constants.KEY_PAGE_END:\n                // handle home and end when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onHomeOrEndKey(key);\n                    processed = true;\n                }\n                break;\n            case constants_1.Constants.KEY_LEFT:\n            case constants_1.Constants.KEY_RIGHT:\n                // handle left and right when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlLeftOrRight(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case constants_1.Constants.KEY_UP:\n            case constants_1.Constants.KEY_DOWN:\n                // handle up and down when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlUpOrDown(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case constants_1.Constants.KEY_PAGE_DOWN:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageDown(currentCell);\n                    processed = true;\n                }\n                break;\n            case constants_1.Constants.KEY_PAGE_UP:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageUp(currentCell);\n                    processed = true;\n                }\n                break;\n        }\n        if (processed) {\n            event.preventDefault();\n        }\n        return processed;\n    };\n    NavigationService.prototype.onPageDown = function (gridCell) {\n        var viewport = this.gridPanel.getPrimaryScrollViewport();\n        var pixelsInOnePage = viewport.offsetHeight;\n        if (this.gridPanel.isHorizontalScrollShowing()) {\n            pixelsInOnePage -= this.scrollWidth;\n        }\n        var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n        var currentPageBottomPixel = viewport.scrollTop + pixelsInOnePage;\n        var currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n        var scrollIndex = currentPageBottomRow;\n        var currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex).rowTop;\n        var nextCellPixel = currentCellPixel + pixelsInOnePage - pagingPixelOffset;\n        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n        var pageLastRow = this.paginationProxy.getPageLastRow();\n        if (focusIndex > pageLastRow) {\n            focusIndex = pageLastRow;\n        }\n        if (scrollIndex > pageLastRow) {\n            scrollIndex = pageLastRow;\n        }\n        this.navigateTo(scrollIndex, 'top', null, focusIndex, gridCell.column);\n    };\n    NavigationService.prototype.onPageUp = function (gridCell) {\n        var viewport = this.gridPanel.getPrimaryScrollViewport();\n        var pixelsInOnePage = viewport.offsetHeight;\n        if (this.gridPanel.isHorizontalScrollShowing()) {\n            pixelsInOnePage -= this.scrollWidth;\n        }\n        var pagingPixelOffset = this.paginationProxy.getPixelOffset();\n        var currentPageTopPixel = viewport.scrollTop;\n        var currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n        var scrollIndex = currentPageTopRow;\n        var currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);\n        var nextCellPixel = currentRowNode.rowTop + currentRowNode.rowHeight - pixelsInOnePage - pagingPixelOffset;\n        var focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n        var firstRow = this.paginationProxy.getPageFirstRow();\n        if (focusIndex < firstRow) {\n            focusIndex = firstRow;\n        }\n        if (scrollIndex < firstRow) {\n            scrollIndex = firstRow;\n        }\n        this.navigateTo(scrollIndex, 'bottom', null, focusIndex, gridCell.column);\n    };\n    // common logic to navigate. takes parameters:\n    // scrollIndex - what row to vertically scroll to\n    // scrollType - what position to put scroll index ie top/bottom\n    // scrollColumn - what column to horizontally scroll to\n    // focusIndex / focusColumn - for page up / down, we want to scroll to one row/column, but focus another\n    NavigationService.prototype.navigateTo = function (scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn) {\n        if (utils_1._.exists(scrollColumn)) {\n            this.gridPanel.ensureColumnVisible(scrollColumn);\n        }\n        if (utils_1._.exists(scrollIndex)) {\n            this.gridPanel.ensureIndexVisible(scrollIndex, scrollType);\n        }\n        // make sure the cell is rendered, needed if we are to focus\n        this.animationFrameService.flushAllFrames();\n        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n        // highlighted.\n        this.focusedCellController.setFocusedCell(focusIndex, focusColumn, null, true);\n        if (this.rangeController) {\n            var gridCell = new gridCell_1.GridCell({ rowIndex: focusIndex, floating: null, column: focusColumn });\n            this.rangeController.setRangeToCell(gridCell);\n        }\n    };\n    // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.\n    NavigationService.prototype.onCtrlUpOrDown = function (key, gridCell) {\n        var upKey = key === constants_1.Constants.KEY_UP;\n        var rowIndexToScrollTo = upKey ? 0 : this.paginationProxy.getPageLastRow();\n        this.navigateTo(rowIndexToScrollTo, null, gridCell.column, rowIndexToScrollTo, gridCell.column);\n    };\n    // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.\n    NavigationService.prototype.onCtrlLeftOrRight = function (key, gridCell) {\n        var leftKey = key === constants_1.Constants.KEY_LEFT;\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var columnToSelect = leftKey ? allColumns[0] : allColumns[allColumns.length - 1];\n        this.navigateTo(gridCell.rowIndex, null, columnToSelect, gridCell.rowIndex, columnToSelect);\n    };\n    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n    // same cell into view (which means either scroll all the way up, or all the way down).\n    NavigationService.prototype.onHomeOrEndKey = function (key) {\n        var homeKey = key === constants_1.Constants.KEY_PAGE_HOME;\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var columnToSelect = homeKey ? allColumns[0] : allColumns[allColumns.length - 1];\n        var rowIndexToScrollTo = homeKey ? 0 : this.paginationProxy.getPageLastRow();\n        this.navigateTo(rowIndexToScrollTo, null, columnToSelect, rowIndexToScrollTo, columnToSelect);\n    };\n    __decorate([\n        context_1.Autowired('gridPanel'),\n        __metadata(\"design:type\", gridPanel_1.GridPanel)\n    ], NavigationService.prototype, \"gridPanel\", void 0);\n    __decorate([\n        context_1.Autowired('mouseEventService'),\n        __metadata(\"design:type\", mouseEventService_1.MouseEventService)\n    ], NavigationService.prototype, \"mouseEventService\", void 0);\n    __decorate([\n        context_1.Autowired('paginationProxy'),\n        __metadata(\"design:type\", paginationProxy_1.PaginationProxy)\n    ], NavigationService.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        context_1.Autowired('focusedCellController'),\n        __metadata(\"design:type\", focusedCellController_1.FocusedCellController)\n    ], NavigationService.prototype, \"focusedCellController\", void 0);\n    __decorate([\n        context_1.Autowired('animationFrameService'),\n        __metadata(\"design:type\", animationFrameService_1.AnimationFrameService)\n    ], NavigationService.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        context_1.Optional('rangeController'),\n        __metadata(\"design:type\", Object)\n    ], NavigationService.prototype, \"rangeController\", void 0);\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], NavigationService.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], NavigationService.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], NavigationService.prototype, \"init\", null);\n    NavigationService = __decorate([\n        context_1.Bean('navigationService')\n    ], NavigationService);\n    return NavigationService;\n}());\nexports.NavigationService = NavigationService;\n",null]}