{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\alignedGridsService.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\alignedGridsService.js","mtime":1525243698324},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v17.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nvar __param = /*@__PURE__*/ require(\"tslib\").__param;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gridOptionsWrapper_1 = require(\"./gridOptionsWrapper\");\nvar columnController_1 = require(\"./columnController/columnController\");\nvar gridPanel_1 = require(\"./gridPanel/gridPanel\");\nvar eventService_1 = require(\"./eventService\");\nvar logger_1 = require(\"./logger\");\nvar events_1 = require(\"./events\");\nvar context_1 = require(\"./context/context\");\nvar context_2 = require(\"./context/context\");\nvar context_3 = require(\"./context/context\");\nvar context_4 = require(\"./context/context\");\nvar counter = 0;\nvar AlignedGridsService = /*@__PURE__*/ (function () {\n    function AlignedGridsService() {\n        this.instanceId = counter++;\n        // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master\n        // while processing a master event) we mark this if consuming an event, and if we are, then\n        // we don't fire back any events.\n        this.consuming = false;\n    }\n    AlignedGridsService.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('AlignedGridsService');\n    };\n    AlignedGridsService.prototype.init = function () {\n        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));\n        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));\n        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));\n        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));\n        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));\n        this.eventService.addEventListener(events_1.Events.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));\n    };\n    // common logic across all the fire methods\n    AlignedGridsService.prototype.fireEvent = function (callback) {\n        // if we are already consuming, then we are acting on an event from a master,\n        // so we don't cause a cyclic firing of events\n        if (this.consuming) {\n            return;\n        }\n        // iterate through the aligned grids, and pass each aligned grid service to the callback\n        var otherGrids = this.gridOptionsWrapper.getAlignedGrids();\n        if (otherGrids) {\n            otherGrids.forEach(function (otherGridOptions) {\n                if (otherGridOptions.api) {\n                    var alignedGridService = otherGridOptions.api.__getAlignedGridService();\n                    callback(alignedGridService);\n                }\n            });\n        }\n    };\n    // common logic across all consume methods. very little common logic, however extracting\n    // guarantees consistency across the methods.\n    AlignedGridsService.prototype.onEvent = function (callback) {\n        this.consuming = true;\n        callback();\n        this.consuming = false;\n    };\n    AlignedGridsService.prototype.fireColumnEvent = function (event) {\n        this.fireEvent(function (alignedGridsService) {\n            alignedGridsService.onColumnEvent(event);\n        });\n    };\n    AlignedGridsService.prototype.fireScrollEvent = function (event) {\n        if (event.direction !== 'horizontal') {\n            return;\n        }\n        this.fireEvent(function (alignedGridsService) {\n            alignedGridsService.onScrollEvent(event);\n        });\n    };\n    AlignedGridsService.prototype.onScrollEvent = function (event) {\n        var _this = this;\n        this.onEvent(function () {\n            _this.gridPanel.setHorizontalScrollPosition(event.left);\n        });\n    };\n    AlignedGridsService.prototype.getMasterColumns = function (event) {\n        var result = [];\n        if (event.columns) {\n            event.columns.forEach(function (column) {\n                result.push(column);\n            });\n        }\n        else if (event.column) {\n            result.push(event.column);\n        }\n        return result;\n    };\n    AlignedGridsService.prototype.getColumnIds = function (event) {\n        var result = [];\n        if (event.columns) {\n            event.columns.forEach(function (column) {\n                result.push(column.getColId());\n            });\n        }\n        else if (event.columns) {\n            result.push(event.column.getColId());\n        }\n        return result;\n    };\n    AlignedGridsService.prototype.onColumnEvent = function (event) {\n        var _this = this;\n        this.onEvent(function () {\n            switch (event.type) {\n                case events_1.Events.EVENT_COLUMN_MOVED:\n                case events_1.Events.EVENT_COLUMN_VISIBLE:\n                case events_1.Events.EVENT_COLUMN_PINNED:\n                case events_1.Events.EVENT_COLUMN_RESIZED:\n                    var colEvent = event;\n                    _this.processColumnEvent(colEvent);\n                    break;\n                case events_1.Events.EVENT_COLUMN_GROUP_OPENED:\n                    var groupOpenedEvent = event;\n                    _this.processGroupOpenedEvent(groupOpenedEvent);\n                    break;\n                case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:\n                    // we cannot support pivoting with aligned grids as the columns will be out of sync as the\n                    // grids will have columns created based on the row data of the grid.\n                    console.warn('ag-Grid: pivoting is not supported with aligned grids. ' +\n                        'You can only use one of these features at a time in a grid.');\n                    break;\n            }\n        });\n    };\n    AlignedGridsService.prototype.processGroupOpenedEvent = function (groupOpenedEvent) {\n        // likewise for column group\n        var masterColumnGroup = groupOpenedEvent.columnGroup;\n        var otherColumnGroup;\n        if (masterColumnGroup) {\n            var groupId = masterColumnGroup.getGroupId();\n            otherColumnGroup = this.columnController.getOriginalColumnGroup(groupId);\n        }\n        if (masterColumnGroup && !otherColumnGroup) {\n            return;\n        }\n        this.logger.log('onColumnEvent-> processing ' + event + ' expanded = ' + masterColumnGroup.isExpanded());\n        this.columnController.setColumnGroupOpened(otherColumnGroup, masterColumnGroup.isExpanded(), \"alignedGridChanged\");\n    };\n    AlignedGridsService.prototype.processColumnEvent = function (colEvent) {\n        var _this = this;\n        // the column in the event is from the master grid. need to\n        // look up the equivalent from this (other) grid\n        var masterColumn = colEvent.column;\n        var otherColumn;\n        if (masterColumn) {\n            otherColumn = this.columnController.getPrimaryColumn(masterColumn.getColId());\n        }\n        // if event was with respect to a master column, that is not present in this\n        // grid, then we ignore the event\n        if (masterColumn && !otherColumn) {\n            return;\n        }\n        // in time, all the methods below should use the column ids, it's a more generic way\n        // of handling columns, and also allows for single or multi column events\n        var columnIds = this.getColumnIds(colEvent);\n        var masterColumns = this.getMasterColumns(colEvent);\n        switch (colEvent.type) {\n            case events_1.Events.EVENT_COLUMN_MOVED:\n                var movedEvent = colEvent;\n                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' toIndex = ' + movedEvent.toIndex);\n                this.columnController.moveColumns(columnIds, movedEvent.toIndex, \"alignedGridChanged\");\n                break;\n            case events_1.Events.EVENT_COLUMN_VISIBLE:\n                var visibleEvent = colEvent;\n                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' visible = ' + visibleEvent.visible);\n                this.columnController.setColumnsVisible(columnIds, visibleEvent.visible, \"alignedGridChanged\");\n                break;\n            case events_1.Events.EVENT_COLUMN_PINNED:\n                var pinnedEvent = colEvent;\n                this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' pinned = ' + pinnedEvent.pinned);\n                this.columnController.setColumnsPinned(columnIds, pinnedEvent.pinned, \"alignedGridChanged\");\n                break;\n            case events_1.Events.EVENT_COLUMN_RESIZED:\n                var resizedEvent_1 = colEvent;\n                masterColumns.forEach(function (masterColumn) {\n                    _this.logger.log('onColumnEvent-> processing ' + colEvent.type + ' actualWidth = ' + masterColumn.getActualWidth());\n                    _this.columnController.setColumnWidth(masterColumn.getColId(), masterColumn.getActualWidth(), false, resizedEvent_1.finished, \"alignedGridChanged\");\n                });\n                break;\n        }\n    };\n    __decorate([\n        context_3.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], AlignedGridsService.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_3.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], AlignedGridsService.prototype, \"columnController\", void 0);\n    __decorate([\n        context_3.Autowired('gridPanel'),\n        __metadata(\"design:type\", gridPanel_1.GridPanel)\n    ], AlignedGridsService.prototype, \"gridPanel\", void 0);\n    __decorate([\n        context_3.Autowired('eventService'),\n        __metadata(\"design:type\", eventService_1.EventService)\n    ], AlignedGridsService.prototype, \"eventService\", void 0);\n    __decorate([\n        __param(0, context_2.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], AlignedGridsService.prototype, \"setBeans\", null);\n    __decorate([\n        context_4.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], AlignedGridsService.prototype, \"init\", null);\n    AlignedGridsService = __decorate([\n        context_1.Bean('alignedGridsService')\n    ], AlignedGridsService);\n    return AlignedGridsService;\n}());\nexports.AlignedGridsService = AlignedGridsService;\n",null]}