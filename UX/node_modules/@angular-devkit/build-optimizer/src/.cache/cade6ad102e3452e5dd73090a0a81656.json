{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\utils.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\utils.js","mtime":1525243698421},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\r\n * @version v17.1.1\r\n * @link http://www.ag-grid.com/\r\n * @license MIT\r\n */\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar constants_1 = require(\"./constants\");\r\nvar FUNCTION_STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\nvar FUNCTION_ARGUMENT_NAMES = /([^\\s,]+)/g;\r\nvar AG_GRID_STOP_PROPAGATION = '__ag_Grid_Stop_Propagation';\r\n// util class, only used when debugging, for printing time to console\r\nvar Timer = /*@__PURE__*/ (function () {\r\n    function Timer() {\r\n        this.timestamp = new Date().getTime();\r\n    }\r\n    Timer.prototype.print = function (msg) {\r\n        var duration = (new Date().getTime()) - this.timestamp;\r\n        console.log(msg + \" = \" + duration);\r\n        this.timestamp = new Date().getTime();\r\n    };\r\n    return Timer;\r\n}());\r\nexports.Timer = Timer;\r\n/** HTML Escapes. */\r\nvar HTML_ESCAPES = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&quot;',\r\n    \"'\": '&#39;'\r\n};\r\nvar reUnescapedHtml = /[&<>\"']/g;\r\nvar Utils = /*@__PURE__*/ (function () {\r\n    function Utils() {\r\n    }\r\n    // if the key was passed before, then doesn't execute the func\r\n    Utils.doOnce = function (func, key) {\r\n        if (this.doOnceFlags[key]) {\r\n            return;\r\n        }\r\n        func();\r\n        this.doOnceFlags[key] = true;\r\n    };\r\n    // returns true if the event is close to the original event by X pixels either vertically or horizontally.\r\n    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.\r\n    Utils.areEventsNear = function (e1, e2, pixelCount) {\r\n        // by default, we wait 4 pixels before starting the drag\r\n        if (pixelCount === 0) {\r\n            return false;\r\n        }\r\n        var diffX = Math.abs(e1.clientX - e2.clientX);\r\n        var diffY = Math.abs(e1.clientY - e2.clientY);\r\n        return Math.max(diffX, diffY) <= pixelCount;\r\n    };\r\n    Utils.shallowCompare = function (arr1, arr2) {\r\n        // if both are missing, then they are the same\r\n        if (this.missing(arr1) && this.missing(arr2)) {\r\n            return true;\r\n        }\r\n        // if one is present, but other is missing, then then are different\r\n        if (this.missing(arr1) || this.missing(arr2)) {\r\n            return false;\r\n        }\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < arr1.length; i++) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Utils.getNameOfClass = function (TheClass) {\r\n        var funcNameRegex = /function (.{1,})\\(/;\r\n        var funcAsString = TheClass.toString();\r\n        var results = (funcNameRegex).exec(funcAsString);\r\n        return (results && results.length > 1) ? results[1] : \"\";\r\n    };\r\n    Utils.values = function (object) {\r\n        var result = [];\r\n        this.iterateObject(object, function (key, value) {\r\n            result.push(value);\r\n        });\r\n        return result;\r\n    };\r\n    Utils.getValueUsingField = function (data, field, fieldContainsDots) {\r\n        if (!field || !data) {\r\n            return;\r\n        }\r\n        // if no '.', then it's not a deep value\r\n        if (!fieldContainsDots) {\r\n            return data[field];\r\n        }\r\n        else {\r\n            // otherwise it is a deep value, so need to dig for it\r\n            var fields = field.split('.');\r\n            var currentObject = data;\r\n            for (var i = 0; i < fields.length; i++) {\r\n                currentObject = currentObject[fields[i]];\r\n                if (this.missing(currentObject)) {\r\n                    return null;\r\n                }\r\n            }\r\n            return currentObject;\r\n        }\r\n    };\r\n    Utils.getScrollLeft = function (element, rtl) {\r\n        var scrollLeft = element.scrollLeft;\r\n        if (rtl) {\r\n            // Absolute value - for FF that reports RTL scrolls in negative numbers\r\n            scrollLeft = Math.abs(scrollLeft);\r\n            // Get Chrome and Safari to return the same value as well\r\n            if (this.isBrowserSafari() || this.isBrowserChrome()) {\r\n                scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\r\n            }\r\n        }\r\n        return scrollLeft;\r\n    };\r\n    Utils.cleanNumber = function (value) {\r\n        if (typeof value === 'string') {\r\n            value = parseInt(value);\r\n        }\r\n        if (typeof value === 'number') {\r\n            value = Math.floor(value);\r\n        }\r\n        else {\r\n            value = null;\r\n        }\r\n        return value;\r\n    };\r\n    Utils.setScrollLeft = function (element, value, rtl) {\r\n        if (rtl) {\r\n            // Chrome and Safari when doing RTL have the END position of the scroll as zero, not the start\r\n            if (this.isBrowserSafari() || this.isBrowserChrome()) {\r\n                value = element.scrollWidth - element.clientWidth - value;\r\n            }\r\n            // Firefox uses negative numbers when doing RTL scrolling\r\n            if (this.isBrowserFirefox()) {\r\n                value *= -1;\r\n            }\r\n        }\r\n        element.scrollLeft = value;\r\n    };\r\n    Utils.iterateNamedNodeMap = function (map, callback) {\r\n        if (!map) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < map.length; i++) {\r\n            var attr = map[i];\r\n            callback(attr.name, attr.value);\r\n        }\r\n    };\r\n    Utils.iterateObject = function (object, callback) {\r\n        if (this.missing(object)) {\r\n            return;\r\n        }\r\n        if (Array.isArray(object)) {\r\n            object.forEach(function (value, index) {\r\n                callback(index + '', value);\r\n            });\r\n        }\r\n        else {\r\n            var keys = Object.keys(object);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                var value = object[key];\r\n                callback(key, value);\r\n            }\r\n        }\r\n    };\r\n    Utils.cloneObject = function (object) {\r\n        var copy = {};\r\n        var keys = Object.keys(object);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            var value = object[key];\r\n            copy[key] = value;\r\n        }\r\n        return copy;\r\n    };\r\n    Utils.map = function (array, callback) {\r\n        var result = [];\r\n        for (var i = 0; i < array.length; i++) {\r\n            var item = array[i];\r\n            var mappedItem = callback(item);\r\n            result.push(mappedItem);\r\n        }\r\n        return result;\r\n    };\r\n    Utils.mapObject = function (object, callback) {\r\n        var result = [];\r\n        Utils.iterateObject(object, function (key, value) {\r\n            result.push(callback(value));\r\n        });\r\n        return result;\r\n    };\r\n    Utils.forEach = function (array, callback) {\r\n        if (!array) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < array.length; i++) {\r\n            var value = array[i];\r\n            callback(value, i);\r\n        }\r\n    };\r\n    Utils.filter = function (array, callback) {\r\n        var result = [];\r\n        array.forEach(function (item) {\r\n            if (callback(item)) {\r\n                result.push(item);\r\n            }\r\n        });\r\n        return result;\r\n    };\r\n    Utils.getAllKeysInObjects = function (objects) {\r\n        var allValues = {};\r\n        objects.forEach(function (obj) {\r\n            if (obj) {\r\n                Object.keys(obj).forEach(function (key) { return allValues[key] = null; });\r\n            }\r\n        });\r\n        return Object.keys(allValues);\r\n    };\r\n    Utils.mergeDeep = function (dest, source) {\r\n        if (this.exists(source)) {\r\n            this.iterateObject(source, function (key, newValue) {\r\n                var oldValue = dest[key];\r\n                if (oldValue === newValue) {\r\n                    return;\r\n                }\r\n                if (typeof oldValue === 'object' && typeof newValue === 'object') {\r\n                    Utils.mergeDeep(oldValue, newValue);\r\n                }\r\n                else {\r\n                    dest[key] = newValue;\r\n                }\r\n            });\r\n        }\r\n    };\r\n    Utils.assign = function (object) {\r\n        var _this = this;\r\n        var sources = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            sources[_i - 1] = arguments[_i];\r\n        }\r\n        sources.forEach(function (source) {\r\n            if (_this.exists(source)) {\r\n                _this.iterateObject(source, function (key, value) {\r\n                    object[key] = value;\r\n                });\r\n            }\r\n        });\r\n        return object;\r\n    };\r\n    Utils.parseYyyyMmDdToDate = function (yyyyMmDd, separator) {\r\n        try {\r\n            if (!yyyyMmDd)\r\n                return null;\r\n            if (yyyyMmDd.indexOf(separator) === -1)\r\n                return null;\r\n            var fields = yyyyMmDd.split(separator);\r\n            if (fields.length != 3)\r\n                return null;\r\n            return new Date(Number(fields[0]), Number(fields[1]) - 1, Number(fields[2]));\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    };\r\n    Utils.serializeDateToYyyyMmDd = function (date, separator) {\r\n        if (!date)\r\n            return null;\r\n        return date.getFullYear() + separator + Utils.pad(date.getMonth() + 1, 2) + separator + Utils.pad(date.getDate(), 2);\r\n    };\r\n    Utils.pad = function (num, totalStringSize) {\r\n        var asString = num + \"\";\r\n        while (asString.length < totalStringSize)\r\n            asString = \"0\" + asString;\r\n        return asString;\r\n    };\r\n    Utils.pushAll = function (target, source) {\r\n        if (this.missing(source) || this.missing(target)) {\r\n            return;\r\n        }\r\n        source.forEach(function (func) { return target.push(func); });\r\n    };\r\n    Utils.createArrayOfNumbers = function (first, last) {\r\n        var result = [];\r\n        for (var i = first; i <= last; i++) {\r\n            result.push(i);\r\n        }\r\n        return result;\r\n    };\r\n    Utils.getFunctionParameters = function (func) {\r\n        var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');\r\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);\r\n        if (result === null) {\r\n            return [];\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    };\r\n    Utils.find = function (collection, predicate, value) {\r\n        if (collection === null || collection === undefined) {\r\n            return null;\r\n        }\r\n        if (!Array.isArray(collection)) {\r\n            var objToArray = this.values(collection);\r\n            return this.find(objToArray, predicate, value);\r\n        }\r\n        var collectionAsArray = collection;\r\n        var firstMatchingItem;\r\n        for (var i = 0; i < collectionAsArray.length; i++) {\r\n            var item = collectionAsArray[i];\r\n            if (typeof predicate === 'string') {\r\n                if (item[predicate] === value) {\r\n                    firstMatchingItem = item;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                var callback = predicate;\r\n                if (callback(item)) {\r\n                    firstMatchingItem = item;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return firstMatchingItem;\r\n    };\r\n    Utils.toStrings = function (array) {\r\n        return this.map(array, function (item) {\r\n            if (item === undefined || item === null || !item.toString) {\r\n                return null;\r\n            }\r\n            else {\r\n                return item.toString();\r\n            }\r\n        });\r\n    };\r\n    Utils.iterateArray = function (array, callback) {\r\n        for (var index = 0; index < array.length; index++) {\r\n            var value = array[index];\r\n            callback(value, index);\r\n        }\r\n    };\r\n    //Returns true if it is a DOM node\r\n    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\r\n    Utils.isNode = function (o) {\r\n        return (typeof Node === \"function\" ? o instanceof Node :\r\n            o && typeof o === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName === \"string\");\r\n    };\r\n    //Returns true if it is a DOM element\r\n    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\r\n    Utils.isElement = function (o) {\r\n        return (typeof HTMLElement === \"function\" ? o instanceof HTMLElement :\r\n            o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\");\r\n    };\r\n    Utils.isNodeOrElement = function (o) {\r\n        return this.isNode(o) || this.isElement(o);\r\n    };\r\n    // makes a copy of a node list into a list\r\n    Utils.copyNodeList = function (nodeList) {\r\n        var childCount = nodeList ? nodeList.length : 0;\r\n        var res = [];\r\n        for (var i = 0; i < childCount; i++) {\r\n            res.push(nodeList[i]);\r\n        }\r\n        return res;\r\n    };\r\n    Utils.isEventFromPrintableCharacter = function (event) {\r\n        var pressedChar = String.fromCharCode(event.charCode);\r\n        // newline is an exception, as it counts as a printable character, but we don't\r\n        // want to start editing when it is pressed. without this check, if user is in chrome\r\n        // and editing a cell, and they press ctrl+enter, the cell stops editing, and then\r\n        // starts editing again with a blank value (two 'key down' events are fired). to\r\n        // test this, remove the line below, edit a cell in chrome and hit ctrl+enter while editing.\r\n        // https://ag-grid.atlassian.net/browse/AG-605\r\n        if (this.isKeyPressed(event, constants_1.Constants.KEY_NEW_LINE)) {\r\n            return false;\r\n        }\r\n        if (exports._.exists(event.key)) {\r\n            // modern browser will implement key, so we return if key is length 1, eg if it is 'a' for the\r\n            // a key, or '2' for the '2' key. non-printable characters have names, eg 'Enter' or 'Backspace'.\r\n            return event.key.length === 1;\r\n        }\r\n        else {\r\n            // otherwise, for older browsers, we test against a list of characters, which doesn't include\r\n            // accents for non-English, but don't care much, as most users are on modern browsers\r\n            return Utils.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0;\r\n        }\r\n    };\r\n    //adds all type of change listeners to an element, intended to be a text field\r\n    Utils.addChangeListener = function (element, listener) {\r\n        element.addEventListener(\"changed\", listener);\r\n        element.addEventListener(\"paste\", listener);\r\n        element.addEventListener(\"input\", listener);\r\n        // IE doesn't fire changed for special keys (eg delete, backspace), so need to\r\n        // listen for this further ones\r\n        element.addEventListener(\"keydown\", listener);\r\n        element.addEventListener(\"keyup\", listener);\r\n    };\r\n    //if value is undefined, null or blank, returns null, otherwise returns the value\r\n    Utils.makeNull = function (value) {\r\n        var valueNoType = value;\r\n        if (value === null || value === undefined || valueNoType === \"\") {\r\n            return null;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    };\r\n    Utils.missing = function (value) {\r\n        return !this.exists(value);\r\n    };\r\n    Utils.missingOrEmpty = function (value) {\r\n        return this.missing(value) || value.length === 0;\r\n    };\r\n    Utils.missingOrEmptyObject = function (value) {\r\n        return this.missing(value) || Object.keys(value).length === 0;\r\n    };\r\n    Utils.exists = function (value) {\r\n        if (value === null || value === undefined || value === '') {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    };\r\n    Utils.firstExistingValue = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < values.length; i++) {\r\n            var value = values[i];\r\n            if (exports._.exists(value))\r\n                return value;\r\n        }\r\n        return null;\r\n    };\r\n    Utils.anyExists = function (values) {\r\n        if (values) {\r\n            for (var i = 0; i < values.length; i++) {\r\n                if (this.exists(values[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Utils.existsAndNotEmpty = function (value) {\r\n        return this.exists(value) && value.length > 0;\r\n    };\r\n    Utils.removeAllChildren = function (node) {\r\n        if (node) {\r\n            while (node.hasChildNodes()) {\r\n                node.removeChild(node.lastChild);\r\n            }\r\n        }\r\n    };\r\n    Utils.removeElement = function (parent, cssSelector) {\r\n        this.removeFromParent(parent.querySelector(cssSelector));\r\n    };\r\n    Utils.removeFromParent = function (node) {\r\n        if (node && node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n        }\r\n    };\r\n    Utils.isVisible = function (element) {\r\n        return (element.offsetParent !== null);\r\n    };\r\n    /**\r\n     * loads the template and returns it as an element. makes up for no simple way in\r\n     * the dom api to load html directly, eg we cannot do this: document.createElement(template)\r\n     */\r\n    Utils.loadTemplate = function (template) {\r\n        var tempDiv = document.createElement(\"div\");\r\n        tempDiv.innerHTML = template;\r\n        return tempDiv.firstChild;\r\n    };\r\n    Utils.appendHtml = function (eContainer, htmlTemplate) {\r\n        if (eContainer.lastChild) {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML\r\n            // we put the items at the start, so new items appear underneath old items,\r\n            // so when expanding/collapsing groups, the new rows don't go on top of the\r\n            // rows below that are moving our of the way\r\n            eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);\r\n        }\r\n        else {\r\n            eContainer.innerHTML = htmlTemplate;\r\n        }\r\n    };\r\n    Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {\r\n        if (addOrRemove) {\r\n            this.addCssClass(element, className);\r\n        }\r\n        else {\r\n            this.removeCssClass(element, className);\r\n        }\r\n    };\r\n    Utils.callIfPresent = function (func) {\r\n        if (func) {\r\n            func();\r\n        }\r\n    };\r\n    Utils.addCssClass = function (element, className) {\r\n        var _this = this;\r\n        if (!className || className.length === 0) {\r\n            return;\r\n        }\r\n        if (className.indexOf(' ') >= 0) {\r\n            className.split(' ').forEach(function (value) { return _this.addCssClass(element, value); });\r\n            return;\r\n        }\r\n        if (element.classList) {\r\n            if (!element.classList.contains(className)) {\r\n                element.classList.add(className);\r\n            }\r\n        }\r\n        else {\r\n            if (element.className && element.className.length > 0) {\r\n                var cssClasses = element.className.split(' ');\r\n                if (cssClasses.indexOf(className) < 0) {\r\n                    cssClasses.push(className);\r\n                    element.className = cssClasses.join(' ');\r\n                }\r\n            }\r\n            else {\r\n                element.className = className;\r\n            }\r\n        }\r\n    };\r\n    Utils.containsClass = function (element, className) {\r\n        if (element.classList) {\r\n            // for modern browsers\r\n            return element.classList.contains(className);\r\n        }\r\n        else if (element.className) {\r\n            // for older browsers, check against the string of class names\r\n            // if only one class, can check for exact match\r\n            var onlyClass = element.className === className;\r\n            // if many classes, check for class name, we have to pad with ' ' to stop other\r\n            // class names that are a substring of this class\r\n            var contains = element.className.indexOf(' ' + className + ' ') >= 0;\r\n            // the padding above then breaks when it's the first or last class names\r\n            var startsWithClass = element.className.indexOf(className + ' ') === 0;\r\n            var endsWithClass = element.className.lastIndexOf(' ' + className) === (element.className.length - className.length - 1);\r\n            return onlyClass || contains || startsWithClass || endsWithClass;\r\n        }\r\n        else {\r\n            // if item is not a node\r\n            return false;\r\n        }\r\n    };\r\n    Utils.getElementAttribute = function (element, attributeName) {\r\n        if (element.attributes) {\r\n            if (element.attributes[attributeName]) {\r\n                var attribute = element.attributes[attributeName];\r\n                return attribute.value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Utils.offsetHeight = function (element) {\r\n        return element && element.clientHeight ? element.clientHeight : 0;\r\n    };\r\n    Utils.offsetWidth = function (element) {\r\n        return element && element.clientWidth ? element.clientWidth : 0;\r\n    };\r\n    Utils.sortNumberArray = function (numberArray) {\r\n        numberArray.sort(function (a, b) { return a - b; });\r\n    };\r\n    Utils.removeCssClass = function (element, className) {\r\n        if (element.classList) {\r\n            if (element.classList.contains(className)) {\r\n                element.classList.remove(className);\r\n            }\r\n        }\r\n        else {\r\n            if (element.className && element.className.length > 0) {\r\n                var cssClasses = element.className.split(' ');\r\n                if (cssClasses.indexOf(className) >= 0) {\r\n                    // remove all instances of the item, not just the first, in case it's in more than once\r\n                    while (cssClasses.indexOf(className) >= 0) {\r\n                        cssClasses.splice(cssClasses.indexOf(className), 1);\r\n                    }\r\n                    element.className = cssClasses.join(' ');\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Utils.removeRepeatsFromArray = function (array, object) {\r\n        if (!array) {\r\n            return;\r\n        }\r\n        for (var index = array.length - 2; index >= 0; index--) {\r\n            var thisOneMatches = array[index] === object;\r\n            var nextOneMatches = array[index + 1] === object;\r\n            if (thisOneMatches && nextOneMatches) {\r\n                array.splice(index + 1, 1);\r\n            }\r\n        }\r\n    };\r\n    Utils.removeFromArray = function (array, object) {\r\n        if (array.indexOf(object) >= 0) {\r\n            array.splice(array.indexOf(object), 1);\r\n        }\r\n    };\r\n    Utils.removeAllFromArray = function (array, toRemove) {\r\n        toRemove.forEach(function (item) {\r\n            if (array.indexOf(item) >= 0) {\r\n                array.splice(array.indexOf(item), 1);\r\n            }\r\n        });\r\n    };\r\n    Utils.insertIntoArray = function (array, object, toIndex) {\r\n        array.splice(toIndex, 0, object);\r\n    };\r\n    Utils.insertArrayIntoArray = function (dest, src, toIndex) {\r\n        if (this.missing(dest) || this.missing(src)) {\r\n            return;\r\n        }\r\n        // put items in backwards, otherwise inserted items end up in reverse order\r\n        for (var i = src.length - 1; i >= 0; i--) {\r\n            var item = src[i];\r\n            this.insertIntoArray(dest, item, toIndex);\r\n        }\r\n    };\r\n    Utils.moveInArray = function (array, objectsToMove, toIndex) {\r\n        var _this = this;\r\n        // first take out it items from the array\r\n        objectsToMove.forEach(function (obj) {\r\n            _this.removeFromArray(array, obj);\r\n        });\r\n        // now add the objects, in same order as provided to us, that means we start at the end\r\n        // as the objects will be pushed to the right as they are inserted\r\n        objectsToMove.slice().reverse().forEach(function (obj) {\r\n            _this.insertIntoArray(array, obj, toIndex);\r\n        });\r\n    };\r\n    Utils.defaultComparator = function (valueA, valueB, accentedCompare) {\r\n        if (accentedCompare === void 0) {\r\n            accentedCompare = false;\r\n        }\r\n        var valueAMissing = valueA === null || valueA === undefined;\r\n        var valueBMissing = valueB === null || valueB === undefined;\r\n        // this is for aggregations sum and avg, where the result can be a number that is wrapped.\r\n        // if we didn't do this, then the toString() value would be used, which would result in\r\n        // the strings getting used instead of the numbers.\r\n        if (valueA && valueA.toNumber) {\r\n            valueA = valueA.toNumber();\r\n        }\r\n        if (valueB && valueB.toNumber) {\r\n            valueB = valueB.toNumber();\r\n        }\r\n        if (valueAMissing && valueBMissing) {\r\n            return 0;\r\n        }\r\n        if (valueAMissing) {\r\n            return -1;\r\n        }\r\n        if (valueBMissing) {\r\n            return 1;\r\n        }\r\n        if (typeof valueA === \"string\") {\r\n            if (!accentedCompare) {\r\n                return doQuickCompare(valueA, valueB);\r\n            }\r\n            else {\r\n                try {\r\n                    // using local compare also allows chinese comparisons\r\n                    return valueA.localeCompare(valueB);\r\n                }\r\n                catch (e) {\r\n                    // if something wrong with localeCompare, eg not supported\r\n                    // by browser, then just continue with the quick one\r\n                    return doQuickCompare(valueA, valueB);\r\n                }\r\n            }\r\n        }\r\n        if (valueA < valueB) {\r\n            return -1;\r\n        }\r\n        else if (valueA > valueB) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n        function doQuickCompare(a, b) {\r\n            return (a > b ? 1 : (a < b ? -1 : 0));\r\n        }\r\n    };\r\n    Utils.compareArrays = function (array1, array2) {\r\n        if (this.missing(array1) && this.missing(array2)) {\r\n            return true;\r\n        }\r\n        if (this.missing(array1) || this.missing(array2)) {\r\n            return false;\r\n        }\r\n        if (array1.length !== array2.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < array1.length; i++) {\r\n            if (array1[i] !== array2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Utils.ensureDomOrder = function (eContainer, eChild, eChildBefore) {\r\n        // if already in right order, do nothing\r\n        if (eChildBefore && eChildBefore.nextSibling === eChild) {\r\n            return;\r\n        }\r\n        if (eChildBefore) {\r\n            if (eChildBefore.nextSibling) {\r\n                // insert between the eRowBefore and the row after it\r\n                eContainer.insertBefore(eChild, eChildBefore.nextSibling);\r\n            }\r\n            else {\r\n                // if nextSibling is missing, means other row is at end, so just append new row at the end\r\n                eContainer.appendChild(eChild);\r\n            }\r\n        }\r\n        else {\r\n            // otherwise put at start\r\n            if (eContainer.firstChild) {\r\n                // insert it at the first location\r\n                eContainer.insertBefore(eChild, eContainer.firstChild);\r\n            }\r\n        }\r\n    };\r\n    Utils.insertWithDomOrder = function (eContainer, eChild, eChildBefore) {\r\n        if (eChildBefore) {\r\n            if (eChildBefore.nextSibling) {\r\n                // insert between the eRowBefore and the row after it\r\n                eContainer.insertBefore(eChild, eChildBefore.nextSibling);\r\n            }\r\n            else {\r\n                // if nextSibling is missing, means other row is at end, so just append new row at the end\r\n                eContainer.appendChild(eChild);\r\n            }\r\n        }\r\n        else {\r\n            if (eContainer.firstChild) {\r\n                // insert it at the first location\r\n                eContainer.insertBefore(eChild, eContainer.firstChild);\r\n            }\r\n            else {\r\n                // otherwise eContainer is empty, so just append it\r\n                eContainer.appendChild(eChild);\r\n            }\r\n        }\r\n    };\r\n    Utils.insertTemplateWithDomOrder = function (eContainer, htmlTemplate, eChildBefore) {\r\n        var res;\r\n        if (eChildBefore) {\r\n            // if previous element exists, just slot in after the previous element\r\n            eChildBefore.insertAdjacentHTML('afterend', htmlTemplate);\r\n            res = eChildBefore.nextSibling;\r\n        }\r\n        else {\r\n            if (eContainer.firstChild) {\r\n                // insert it at the first location\r\n                eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);\r\n            }\r\n            else {\r\n                // otherwise eContainer is empty, so just append it\r\n                eContainer.innerHTML = htmlTemplate;\r\n            }\r\n            res = eContainer.firstChild;\r\n        }\r\n        return res;\r\n    };\r\n    Utils.every = function (items, callback) {\r\n        if (!items || items.length === 0) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < items.length; i++) {\r\n            if (!callback(items[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Utils.toStringOrNull = function (value) {\r\n        if (this.exists(value) && value.toString) {\r\n            return value.toString();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Utils.formatWidth = function (width) {\r\n        if (typeof width === \"number\") {\r\n            return width + \"px\";\r\n        }\r\n        else {\r\n            return width;\r\n        }\r\n    };\r\n    Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {\r\n        if (typeof value !== 'number') {\r\n            return '';\r\n        }\r\n        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript\r\n        return (Math.round(value * 100) / 100).toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\");\r\n    };\r\n    // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE,\r\n    // so we use this method instead\r\n    Utils.formatNumberCommas = function (value) {\r\n        if (typeof value !== 'number') {\r\n            return '';\r\n        }\r\n        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript\r\n        return value.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\");\r\n    };\r\n    Utils.prependDC = function (parent, documentFragment) {\r\n        if (this.exists(parent.firstChild)) {\r\n            parent.insertBefore(documentFragment, parent.firstChild);\r\n        }\r\n        else {\r\n            parent.appendChild(documentFragment);\r\n        }\r\n    };\r\n    /**\r\n     * If icon provided, use this (either a string, or a function callback).\r\n     * if not, then use the default icon from the theme\r\n     */\r\n    Utils.createIcon = function (iconName, gridOptionsWrapper, column) {\r\n        var iconContents = this.createIconNoSpan(iconName, gridOptionsWrapper, column);\r\n        if (iconContents.className.indexOf('ag-icon') > -1) {\r\n            return iconContents;\r\n        }\r\n        else {\r\n            var eResult = document.createElement('span');\r\n            eResult.appendChild(iconContents);\r\n            return eResult;\r\n        }\r\n    };\r\n    Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, column) {\r\n        var userProvidedIcon;\r\n        // check col for icon first\r\n        if (column && column.getColDef().icons) {\r\n            userProvidedIcon = column.getColDef().icons[iconName];\r\n        }\r\n        // it not in col, try grid options\r\n        if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {\r\n            userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];\r\n        }\r\n        // now if user provided, use it\r\n        if (userProvidedIcon) {\r\n            var rendererResult = void 0;\r\n            if (typeof userProvidedIcon === 'function') {\r\n                rendererResult = userProvidedIcon();\r\n            }\r\n            else if (typeof userProvidedIcon === 'string') {\r\n                rendererResult = userProvidedIcon;\r\n            }\r\n            else {\r\n                throw 'icon from grid options needs to be a string or a function';\r\n            }\r\n            if (typeof rendererResult === 'string') {\r\n                return this.loadTemplate(rendererResult);\r\n            }\r\n            else if (this.isNodeOrElement(rendererResult)) {\r\n                return rendererResult;\r\n            }\r\n            else {\r\n                throw 'iconRenderer should return back a string or a dom object';\r\n            }\r\n        }\r\n        else {\r\n            var span = document.createElement('span');\r\n            var cssClass = this.iconNameClassMap[iconName];\r\n            if (!cssClass) {\r\n                throw new Error(iconName + \" did not find class\");\r\n            }\r\n            span.setAttribute(\"class\", \"ag-icon ag-icon-\" + cssClass);\r\n            return span;\r\n        }\r\n    };\r\n    Utils.addStylesToElement = function (eElement, styles) {\r\n        var _this = this;\r\n        if (!styles) {\r\n            return;\r\n        }\r\n        Object.keys(styles).forEach(function (key) {\r\n            var keyCamelCase = _this.hyphenToCamelCase(key);\r\n            eElement.style[keyCamelCase] = styles[key];\r\n        });\r\n    };\r\n    Utils.isHorizontalScrollShowing = function (element) {\r\n        return element.clientWidth < element.scrollWidth;\r\n    };\r\n    Utils.isVerticalScrollShowing = function (element) {\r\n        return element.clientHeight < element.scrollHeight;\r\n    };\r\n    Utils.getMaxDivHeight = function () {\r\n        if (!document.body) {\r\n            return -1;\r\n        }\r\n        var res = 1000000;\r\n        // FF reports the height back but still renders blank after ~6M px\r\n        var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\r\n        var div = this.loadTemplate(\"<div/>\");\r\n        document.body.appendChild(div);\r\n        while (true) {\r\n            var test = res * 2;\r\n            div.style.height = test + 'px';\r\n            if (test > testUpTo || div.clientHeight !== test) {\r\n                break;\r\n            }\r\n            else {\r\n                res = test;\r\n            }\r\n        }\r\n        document.body.removeChild(div);\r\n        return res;\r\n    };\r\n    Utils.getScrollbarWidth = function () {\r\n        var outer = document.createElement(\"div\");\r\n        outer.style.visibility = \"hidden\";\r\n        outer.style.width = \"100px\";\r\n        outer.style.msOverflowStyle = \"scrollbar\"; // needed for WinJS apps\r\n        document.body.appendChild(outer);\r\n        var widthNoScroll = outer.offsetWidth;\r\n        // force scrollbars\r\n        outer.style.overflow = \"scroll\";\r\n        // add innerdiv\r\n        var inner = document.createElement(\"div\");\r\n        inner.style.width = \"100%\";\r\n        outer.appendChild(inner);\r\n        var widthWithScroll = inner.offsetWidth;\r\n        // remove divs\r\n        outer.parentNode.removeChild(outer);\r\n        return widthNoScroll - widthWithScroll;\r\n    };\r\n    Utils.isKeyPressed = function (event, keyToCheck) {\r\n        var pressedKey = event.which || event.keyCode;\r\n        return pressedKey === keyToCheck;\r\n    };\r\n    Utils.setVisible = function (element, visible) {\r\n        this.addOrRemoveCssClass(element, 'ag-hidden', !visible);\r\n    };\r\n    Utils.setHidden = function (element, hidden) {\r\n        this.addOrRemoveCssClass(element, 'ag-visibility-hidden', hidden);\r\n    };\r\n    Utils.isBrowserIE = function () {\r\n        if (this.isIE === undefined) {\r\n            this.isIE = false || !!document.documentMode; // At least IE6\r\n        }\r\n        return this.isIE;\r\n    };\r\n    Utils.isBrowserEdge = function () {\r\n        if (this.isEdge === undefined) {\r\n            this.isEdge = !this.isBrowserIE() && !!window.StyleMedia;\r\n        }\r\n        return this.isEdge;\r\n    };\r\n    Utils.isBrowserSafari = function () {\r\n        if (this.isSafari === undefined) {\r\n            var anyWindow = window;\r\n            // taken from https://github.com/ag-grid/ag-grid/issues/550\r\n            this.isSafari = Object.prototype.toString.call(anyWindow.HTMLElement).indexOf('Constructor') > 0\r\n                || (function (p) {\r\n                    return p.toString() === \"[object SafariRemoteNotification]\";\r\n                })(!anyWindow.safari || anyWindow.safari.pushNotification);\r\n        }\r\n        return this.isSafari;\r\n    };\r\n    Utils.isBrowserChrome = function () {\r\n        if (this.isChrome === undefined) {\r\n            var anyWindow = window;\r\n            this.isChrome = !!anyWindow.chrome && !!anyWindow.chrome.webstore;\r\n        }\r\n        return this.isChrome;\r\n    };\r\n    Utils.isBrowserFirefox = function () {\r\n        if (this.isFirefox === undefined) {\r\n            var anyWindow = window;\r\n            this.isFirefox = typeof anyWindow.InstallTrigger !== 'undefined';\r\n        }\r\n        return this.isFirefox;\r\n    };\r\n    Utils.isUserAgentIPad = function () {\r\n        if (this.isIPad === undefined) {\r\n            // taken from https://davidwalsh.name/detect-ipad\r\n            this.isIPad = navigator.userAgent.match(/iPad/i) != null;\r\n        }\r\n        return this.isIPad;\r\n    };\r\n    // srcElement is only available in IE. In all other browsers it is target\r\n    // http://stackoverflow.com/questions/5301643/how-can-i-make-event-srcelement-work-in-firefox-and-what-does-it-mean\r\n    Utils.getTarget = function (event) {\r\n        var eventNoType = event;\r\n        return eventNoType.target || eventNoType.srcElement;\r\n    };\r\n    Utils.isElementInEventPath = function (element, event) {\r\n        if (!event || !element) {\r\n            return false;\r\n        }\r\n        var path = exports._.getEventPath(event);\r\n        return path.indexOf(element) >= 0;\r\n    };\r\n    Utils.createEventPath = function (event) {\r\n        var res = [];\r\n        var pointer = exports._.getTarget(event);\r\n        while (pointer) {\r\n            res.push(pointer);\r\n            pointer = pointer.parentElement;\r\n        }\r\n        return res;\r\n    };\r\n    // firefox doesn't have event.path set, or any alternative to it, so we hack\r\n    // it in. this is needed as it's to late to work out the path when the item is\r\n    // removed from the dom. used by MouseEventService, where it works out if a click\r\n    // was from the current grid, or a detail grid (master / detail).\r\n    Utils.addAgGridEventPath = function (event) {\r\n        event.__agGridEventPath = this.getEventPath(event);\r\n    };\r\n    Utils.getEventPath = function (event) {\r\n        // https://stackoverflow.com/questions/39245488/event-path-undefined-with-firefox-and-vue-js\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/Event\r\n        var eventNoType = event;\r\n        if (event.deepPath) {\r\n            // IE supports deep path\r\n            return event.deepPath();\r\n        }\r\n        else if (eventNoType.path) {\r\n            // Chrome supports path\r\n            return eventNoType.path;\r\n        }\r\n        else if (eventNoType.composedPath) {\r\n            // Firefox supports composePath\r\n            return eventNoType.composedPath();\r\n        }\r\n        else if (eventNoType.__agGridEventPath) {\r\n            // Firefox supports composePath\r\n            return eventNoType.__agGridEventPath;\r\n        }\r\n        else {\r\n            // and finally, if none of the above worked,\r\n            // we create the path ourselves\r\n            return this.createEventPath(event);\r\n        }\r\n    };\r\n    Utils.forEachSnapshotFirst = function (list, callback) {\r\n        if (list) {\r\n            var arrayCopy = list.slice(0);\r\n            arrayCopy.forEach(callback);\r\n        }\r\n    };\r\n    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code\r\n    Utils.getBodyWidth = function () {\r\n        if (document.body) {\r\n            return document.body.clientWidth;\r\n        }\r\n        if (window.innerHeight) {\r\n            return window.innerWidth;\r\n        }\r\n        if (document.documentElement && document.documentElement.clientWidth) {\r\n            return document.documentElement.clientWidth;\r\n        }\r\n        return -1;\r\n    };\r\n    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code\r\n    Utils.getBodyHeight = function () {\r\n        if (document.body) {\r\n            return document.body.clientHeight;\r\n        }\r\n        if (window.innerHeight) {\r\n            return window.innerHeight;\r\n        }\r\n        if (document.documentElement && document.documentElement.clientHeight) {\r\n            return document.documentElement.clientHeight;\r\n        }\r\n        return -1;\r\n    };\r\n    Utils.setCheckboxState = function (eCheckbox, state) {\r\n        if (typeof state === 'boolean') {\r\n            eCheckbox.checked = state;\r\n            eCheckbox.indeterminate = false;\r\n        }\r\n        else {\r\n            // isNodeSelected returns back undefined if it's a group and the children\r\n            // are a mix of selected and unselected\r\n            eCheckbox.indeterminate = true;\r\n        }\r\n    };\r\n    Utils.traverseNodesWithKey = function (nodes, callback) {\r\n        var keyParts = [];\r\n        recursiveSearchNodes(nodes);\r\n        function recursiveSearchNodes(nodes) {\r\n            nodes.forEach(function (node) {\r\n                if (node.group) {\r\n                    keyParts.push(node.key);\r\n                    var key = keyParts.join('|');\r\n                    callback(node, key);\r\n                    recursiveSearchNodes(node.childrenAfterGroup);\r\n                    keyParts.pop();\r\n                }\r\n            });\r\n        }\r\n    };\r\n    // from https://gist.github.com/youssman/745578062609e8acac9f\r\n    Utils.camelCaseToHyphen = function (str) {\r\n        if (str === null || str === undefined) {\r\n            return null;\r\n        }\r\n        return str.replace(/([A-Z])/g, function (g) { return '-' + g[0].toLowerCase(); });\r\n    };\r\n    // from https://stackoverflow.com/questions/6660977/convert-hyphens-to-camel-case-camelcase\r\n    Utils.hyphenToCamelCase = function (str) {\r\n        if (str === null || str === undefined) {\r\n            return null;\r\n        }\r\n        return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });\r\n    };\r\n    // pas in an object eg: {color: 'black', top: '25px'} and it returns \"color: black; top: 25px;\" for html\r\n    Utils.cssStyleObjectToMarkup = function (stylesToUse) {\r\n        var _this = this;\r\n        if (!stylesToUse) {\r\n            return '';\r\n        }\r\n        var resParts = [];\r\n        this.iterateObject(stylesToUse, function (styleKey, styleValue) {\r\n            var styleKeyDashed = _this.camelCaseToHyphen(styleKey);\r\n            resParts.push(styleKeyDashed + \": \" + styleValue + \";\");\r\n        });\r\n        return resParts.join(' ');\r\n    };\r\n    /**\r\n     * From http://stackoverflow.com/questions/9716468/is-there-any-function-like-isnumeric-in-javascript-to-validate-numbers\r\n     */\r\n    Utils.isNumeric = function (value) {\r\n        if (value === '')\r\n            return false;\r\n        return !isNaN(parseFloat(value)) && isFinite(value);\r\n    };\r\n    Utils.escape = function (toEscape) {\r\n        if (toEscape === null || toEscape === undefined || !toEscape.replace) {\r\n            return toEscape;\r\n        }\r\n        return toEscape.replace(reUnescapedHtml, function (chr) { return HTML_ESCAPES[chr]; });\r\n    };\r\n    // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\r\n    /**\r\n     * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\r\n     * complicated, thus this doc is long and (hopefully) detailed enough to answer\r\n     * your questions.\r\n     *\r\n     * If you need to react to the mouse wheel in a predictable way, this code is\r\n     * like your bestest friend. * hugs *\r\n     *\r\n     * As of today, there are 4 DOM event types you can listen to:\r\n     *\r\n     *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\r\n     *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\r\n     *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\r\n     *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\r\n     *\r\n     * So what to do?  The is the best:\r\n     *\r\n     *   normalizeWheel.getEventType();\r\n     *\r\n     * In your event callback, use this code to get sane interpretation of the\r\n     * deltas.  This code will return an object with properties:\r\n     *\r\n     *   spinX   -- normalized spin speed (use for zoom) - x plane\r\n     *   spinY   -- \" - y plane\r\n     *   pixelX  -- normalized distance (to pixels) - x plane\r\n     *   pixelY  -- \" - y plane\r\n     *\r\n     * Wheel values are provided by the browser assuming you are using the wheel to\r\n     * scroll a web page by a number of lines or pixels (or pages).  Values can vary\r\n     * significantly on different platforms and browsers, forgetting that you can\r\n     * scroll at different speeds.  Some devices (like trackpads) emit more events\r\n     * at smaller increments with fine granularity, and some emit massive jumps with\r\n     * linear speed or acceleration.\r\n     *\r\n     * This code does its best to normalize the deltas for you:\r\n     *\r\n     *   - spin is trying to normalize how far the wheel was spun (or trackpad\r\n     *     dragged).  This is super useful for zoom support where you want to\r\n     *     throw away the chunky scroll steps on the PC and make those equal to\r\n     *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\r\n     *     resolve a single slow step on a wheel to 1.\r\n     *\r\n     *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\r\n     *     get the crazy differences between browsers, but at least it'll be in\r\n     *     pixels!\r\n     *\r\n     *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\r\n     *     should translate to positive value zooming IN, negative zooming OUT.\r\n     *     This matches the newer 'wheel' event.\r\n     *\r\n     * Why are there spinX, spinY (or pixels)?\r\n     *\r\n     *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\r\n     *     with a mouse.  It results in side-scrolling in the browser by default.\r\n     *\r\n     *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\r\n     *\r\n     *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\r\n     *     probably is by browsers in conjunction with fancy 3D controllers .. but\r\n     *     you know.\r\n     *\r\n     * Implementation info:\r\n     *\r\n     * Examples of 'wheel' event if you scroll slowly (down) by one step with an\r\n     * average mouse:\r\n     *\r\n     *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\r\n     *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\r\n     *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\r\n     *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\r\n     *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\r\n     *\r\n     * On the trackpad:\r\n     *\r\n     *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\r\n     *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\r\n     *\r\n     * On other/older browsers.. it's more complicated as there can be multiple and\r\n     * also missing delta values.\r\n     *\r\n     * The 'wheel' event is more standard:\r\n     *\r\n     * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\r\n     *\r\n     * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\r\n     * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\r\n     * backward compatibility with older events.  Those other values help us\r\n     * better normalize spin speed.  Example of what the browsers provide:\r\n     *\r\n     *                          | event.wheelDelta | event.detail\r\n     *        ------------------+------------------+--------------\r\n     *          Safari v5/OS X  |       -120       |       0\r\n     *          Safari v5/Win7  |       -120       |       0\r\n     *         Chrome v17/OS X  |       -120       |       0\r\n     *         Chrome v17/Win7  |       -120       |       0\r\n     *                IE9/Win7  |       -120       |   undefined\r\n     *         Firefox v4/OS X  |     undefined    |       1\r\n     *         Firefox v4/Win7  |     undefined    |       3\r\n     *\r\n     */\r\n    Utils.normalizeWheel = function (event) {\r\n        var PIXEL_STEP = 10;\r\n        var LINE_HEIGHT = 40;\r\n        var PAGE_HEIGHT = 800;\r\n        // spinX, spinY\r\n        var sX = 0;\r\n        var sY = 0;\r\n        // pixelX, pixelY\r\n        var pX = 0;\r\n        var pY = 0;\r\n        // Legacy\r\n        if ('detail' in event) {\r\n            sY = event.detail;\r\n        }\r\n        if ('wheelDelta' in event) {\r\n            sY = -event.wheelDelta / 120;\r\n        }\r\n        if ('wheelDeltaY' in event) {\r\n            sY = -event.wheelDeltaY / 120;\r\n        }\r\n        if ('wheelDeltaX' in event) {\r\n            sX = -event.wheelDeltaX / 120;\r\n        }\r\n        // side scrolling on FF with DOMMouseScroll\r\n        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\r\n            sX = sY;\r\n            sY = 0;\r\n        }\r\n        pX = sX * PIXEL_STEP;\r\n        pY = sY * PIXEL_STEP;\r\n        if ('deltaY' in event) {\r\n            pY = event.deltaY;\r\n        }\r\n        if ('deltaX' in event) {\r\n            pX = event.deltaX;\r\n        }\r\n        if ((pX || pY) && event.deltaMode) {\r\n            if (event.deltaMode == 1) {\r\n                pX *= LINE_HEIGHT;\r\n                pY *= LINE_HEIGHT;\r\n            }\r\n            else {\r\n                pX *= PAGE_HEIGHT;\r\n                pY *= PAGE_HEIGHT;\r\n            }\r\n        }\r\n        // Fall-back if spin cannot be determined\r\n        if (pX && !sX) {\r\n            sX = (pX < 1) ? -1 : 1;\r\n        }\r\n        if (pY && !sY) {\r\n            sY = (pY < 1) ? -1 : 1;\r\n        }\r\n        return {\r\n            spinX: sX,\r\n            spinY: sY,\r\n            pixelX: pX,\r\n            pixelY: pY\r\n        };\r\n    };\r\n    /**\r\n     * https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript\r\n     */\r\n    Utils.debounce = function (func, wait, immediate) {\r\n        if (immediate === void 0) {\r\n            immediate = false;\r\n        }\r\n        // 'private' variable for instance\r\n        // The returned function will be able to reference this due to closure.\r\n        // Each call to the returned function will share this common timer.\r\n        var timeout;\r\n        // Calling debounce returns a new anonymous function\r\n        return function () {\r\n            // reference the context and args for the setTimeout function\r\n            var context = this, args = arguments;\r\n            // Should the function be called now? If immediate is true\r\n            //   and not already in a timeout then the answer is: Yes\r\n            var callNow = immediate && !timeout;\r\n            // This is the basic debounce behaviour where you can call this\r\n            //   function several times, but it will only execute once\r\n            //   [before or after imposing a delay].\r\n            //   Each time the returned function is called, the timer starts over.\r\n            clearTimeout(timeout);\r\n            // Set the new timeout\r\n            timeout = setTimeout(function () {\r\n                // Inside the timeout function, clear the timeout variable\r\n                // which will let the next execution run when in 'immediate' mode\r\n                timeout = null;\r\n                // Check if the function already ran with the immediate flag\r\n                if (!immediate) {\r\n                    // Call the original function with apply\r\n                    // apply lets you define the 'this' object as well as the arguments\r\n                    //    (both captured before setTimeout)\r\n                    func.apply(context, args);\r\n                }\r\n            }, wait);\r\n            // Immediate mode and no wait timer? Execute the function..\r\n            if (callNow)\r\n                func.apply(context, args);\r\n        };\r\n    };\r\n    ;\r\n    // a user once raised an issue - they said that when you opened a popup (eg context menu)\r\n    // and then clicked on a selection checkbox, the popup wasn't closed. this is because the\r\n    // popup listens for clicks on the body, however ag-grid WAS stopping propagation on the\r\n    // checkbox clicks (so the rows didn't pick them up as row selection selection clicks).\r\n    // to get around this, we have a pattern to stop propagation for the purposes of ag-Grid,\r\n    // but we still let the event pass back to teh body.\r\n    Utils.stopPropagationForAgGrid = function (event) {\r\n        event[AG_GRID_STOP_PROPAGATION] = true;\r\n    };\r\n    Utils.isStopPropagationForAgGrid = function (event) {\r\n        return event[AG_GRID_STOP_PROPAGATION] === true;\r\n    };\r\n    Utils.executeInAWhile = function (funcs) {\r\n        this.executeAfter(funcs, 400);\r\n    };\r\n    Utils.executeNextVMTurn = function (funcs) {\r\n        this.executeAfter(funcs, 0);\r\n    };\r\n    Utils.executeAfter = function (funcs, millis) {\r\n        if (funcs.length > 0) {\r\n            setTimeout(function () {\r\n                funcs.forEach(function (func) { return func(); });\r\n            }, millis);\r\n        }\r\n    };\r\n    Utils.referenceCompare = function (left, right) {\r\n        if (left == null && right == null)\r\n            return true;\r\n        if (left == null && right)\r\n            return false;\r\n        if (left && right == null)\r\n            return false;\r\n        return left === right;\r\n    };\r\n    Utils.get = function (source, expression, defaultValue) {\r\n        if (source == null)\r\n            return defaultValue;\r\n        if (expression.indexOf('.') > -1) {\r\n            var fields = expression.split('.');\r\n            var thisKey = fields[0];\r\n            var nextValue = source[thisKey];\r\n            if (nextValue != null) {\r\n                return Utils.get(nextValue, fields.slice(1, fields.length).join('.'), defaultValue);\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n        else {\r\n            var nextValue = source[expression];\r\n            return nextValue != null ? nextValue : defaultValue;\r\n        }\r\n    };\r\n    Utils.addSafePassiveEventListener = function (eElement, event, listener) {\r\n        eElement.addEventListener(event, listener, (Utils.passiveEvents.indexOf(event) > -1 ? { passive: true } : undefined));\r\n    };\r\n    Utils.camelCaseToHumanText = function (camelCase) {\r\n        if (camelCase == null)\r\n            return null;\r\n        // Who needs to learn how to code when you have stack overflow!\r\n        // from: https://stackoverflow.com/questions/15369566/putting-space-in-camel-case-string-using-regular-expression\r\n        var rex = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g;\r\n        var words = camelCase.replace(rex, '$1$4 $2$3$5').replace('.', ' ').split(' ');\r\n        return words.map(function (word) { return word.substring(0, 1).toUpperCase() + ((word.length > 1) ? word.substring(1, word.length) : ''); }).join(' ');\r\n    };\r\n    // displays a message to the browser. this is useful in iPad, where you can't easily see the console.\r\n    // so the javascript code can use this to give feedback. this is NOT intended to be called in production.\r\n    // it is intended the ag-Grid developer calls this to troubleshoot, but then takes out the calls before\r\n    // checking in.\r\n    Utils.message = function (msg) {\r\n        var eMessage = document.createElement('div');\r\n        eMessage.innerHTML = msg;\r\n        var eBox = document.querySelector('#__ag__message');\r\n        if (!eBox) {\r\n            var template = \"<div id=\\\"__ag__message\\\" style=\\\"display: inline-block; position: absolute; top: 0px; left: 0px; color: white; background-color: black; z-index: 20; padding: 2px; border: 1px solid darkred; height: 200px; overflow-y: auto;\\\"></div>\";\r\n            eBox = this.loadTemplate(template);\r\n            if (document.body) {\r\n                document.body.appendChild(eBox);\r\n            }\r\n        }\r\n        eBox.appendChild(eMessage);\r\n    };\r\n    // gets called by: a) InMemoryRowNodeManager and b) GroupStage to do sorting.\r\n    // when in InMemoryRowNodeManager we always have indexes (as this sorts the items the\r\n    // user provided) but when in GroupStage, the nodes can contain filler nodes that\r\n    // don't have order id's\r\n    Utils.sortRowNodesByOrder = function (rowNodes, rowNodeOrder) {\r\n        if (!rowNodes) {\r\n            return;\r\n        }\r\n        rowNodes.sort(function (nodeA, nodeB) {\r\n            var positionA = rowNodeOrder[nodeA.id];\r\n            var positionB = rowNodeOrder[nodeB.id];\r\n            var aHasIndex = positionA !== undefined;\r\n            var bHasIndex = positionB !== undefined;\r\n            var bothNodesAreUserNodes = aHasIndex && bHasIndex;\r\n            var bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;\r\n            if (bothNodesAreUserNodes) {\r\n                // when comparing two nodes the user has provided, they always\r\n                // have indexes\r\n                return positionA - positionB;\r\n            }\r\n            else if (bothNodesAreFillerNodes) {\r\n                // when comparing two filler nodes, we have no index to compare them\r\n                // against, however we want this sorting to be deterministic, so that\r\n                // the rows don't jump around as the user does delta updates. so we\r\n                // want the same sort result. so we use the id - which doesn't make sense\r\n                // from a sorting point of view, but does give consistent behaviour between\r\n                // calls. otherwise groups jump around as delta updates are done.\r\n                return nodeA.id > nodeB.id ? 1 : -1;\r\n            }\r\n            else if (aHasIndex) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        });\r\n    };\r\n    Utils.fuzzyCheckStrings = function (inputValues, validValues, allSuggestions) {\r\n        var _this = this;\r\n        var fuzzyMatches = {};\r\n        var invalidInputs = inputValues.filter(function (inputValue) {\r\n            return !validValues.some(function (validValue) { return validValue === inputValue; });\r\n        });\r\n        if (invalidInputs.length > 0) {\r\n            invalidInputs.forEach(function (invalidInput) {\r\n                return fuzzyMatches[invalidInput] = _this.fuzzySuggestions(invalidInput, validValues, allSuggestions);\r\n            });\r\n        }\r\n        return fuzzyMatches;\r\n    };\r\n    Utils.fuzzySuggestions = function (inputValue, validValues, allSuggestions) {\r\n        var thisSuggestions = allSuggestions.slice(0);\r\n        thisSuggestions.sort(function (suggestedValueLeft, suggestedValueRight) {\r\n            var leftDifference = exports._.string_similarity(suggestedValueLeft.toLowerCase(), inputValue.toLowerCase());\r\n            var rightDifference = exports._.string_similarity(suggestedValueRight.toLowerCase(), inputValue.toLowerCase());\r\n            return leftDifference > rightDifference ? -1 :\r\n                leftDifference === rightDifference ? 0 :\r\n                    1;\r\n        });\r\n        return thisSuggestions;\r\n    };\r\n    //Algorithm to do fuzzy search\r\n    //https://stackoverflow.com/questions/23305000/javascript-fuzzy-search-that-makes-sense\r\n    Utils.get_bigrams = function (from) {\r\n        var i, j, ref, s, v;\r\n        s = from.toLowerCase();\r\n        v = new Array(s.length - 1);\r\n        for (i = j = 0, ref = v.length; j <= ref; i = j += 1) {\r\n            v[i] = s.slice(i, i + 2);\r\n        }\r\n        return v;\r\n    };\r\n    Utils.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!\"$%^&*()_+-=[];\\'#,./\\\\|<>?:@~{}';\r\n    Utils.doOnceFlags = {};\r\n    // static prepend(parent: HTMLElement, child: HTMLElement): void {\r\n    //     if (this.exists(parent.firstChild)) {\r\n    //         parent.insertBefore(child, parent.firstChild);\r\n    //     } else {\r\n    //         parent.appendChild(child);\r\n    //     }\r\n    // }\r\n    Utils.iconNameClassMap = {\r\n        'columnMovePin': 'pin',\r\n        'columnMoveAdd': 'plus',\r\n        'columnMoveHide': 'eye-slash',\r\n        'columnMoveMove': 'arrows',\r\n        'columnMoveLeft': 'left',\r\n        'columnMoveRight': 'right',\r\n        'columnMoveGroup': 'group',\r\n        'columnMoveValue': 'aggregation',\r\n        'columnMovePivot': 'pivot',\r\n        'dropNotAllowed': 'not-allowed',\r\n        'groupContracted': 'expanded',\r\n        'groupExpanded': 'contracted',\r\n        'checkboxChecked': 'checkbox-checked',\r\n        'checkboxUnchecked': 'checkbox-unchecked',\r\n        'checkboxIndeterminate': 'checkbox-indeterminate',\r\n        'checkboxCheckedReadOnly': 'checkbox-checked-readonly',\r\n        'checkboxUncheckedReadOnly': 'checkbox-unchecked-readonly',\r\n        'checkboxIndeterminateReadOnly': 'checkbox-indeterminate-readonly',\r\n        'groupLoading': 'loading',\r\n        'menu': 'menu',\r\n        'filter': 'filter',\r\n        'columns': 'columns',\r\n        'menuPin': 'pin',\r\n        'menuValue': 'aggregation',\r\n        'menuAddRowGroup': 'group',\r\n        'menuRemoveRowGroup': 'group',\r\n        'clipboardCopy': 'copy',\r\n        'clipboardCut': 'cut',\r\n        'clipboardPaste': 'paste',\r\n        'pivotPanel': 'pivot',\r\n        'rowGroupPanel': 'group',\r\n        'valuePanel': 'aggregation',\r\n        'columnGroupOpened': 'expanded',\r\n        'columnGroupClosed': 'contracted',\r\n        'columnSelectClosed': 'tree-closed',\r\n        'columnSelectOpen': 'tree-open',\r\n        // from deprecated header, remove at some point\r\n        'sortAscending': 'asc',\r\n        'sortDescending': 'desc',\r\n        'sortUnSort': 'none'\r\n    };\r\n    Utils.passiveEvents = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\r\n    Utils.string_similarity = function (str1, str2) {\r\n        var hit_count, j, k, len, len1, pairs1, pairs2, union, x, y;\r\n        if (str1.length > 0 && str2.length > 0) {\r\n            pairs1 = Utils.get_bigrams(str1);\r\n            pairs2 = Utils.get_bigrams(str2);\r\n            union = pairs1.length + pairs2.length;\r\n            hit_count = 0;\r\n            for (j = 0, len = pairs1.length; j < len; j++) {\r\n                x = pairs1[j];\r\n                for (k = 0, len1 = pairs2.length; k < len1; k++) {\r\n                    y = pairs2[k];\r\n                    if (x === y) {\r\n                        hit_count++;\r\n                    }\r\n                }\r\n            }\r\n            if (hit_count > 0) {\r\n                return (2.0 * hit_count) / union;\r\n            }\r\n        }\r\n        return 0.0;\r\n    };\r\n    return Utils;\r\n}());\r\nexports.Utils = Utils;\r\nvar NumberSequence = /*@__PURE__*/ (function () {\r\n    function NumberSequence(initValue, step) {\r\n        if (initValue === void 0) {\r\n            initValue = 0;\r\n        }\r\n        if (step === void 0) {\r\n            step = 1;\r\n        }\r\n        this.nextValue = initValue;\r\n        this.step = step;\r\n    }\r\n    NumberSequence.prototype.next = function () {\r\n        var valToReturn = this.nextValue;\r\n        this.nextValue += this.step;\r\n        return valToReturn;\r\n    };\r\n    NumberSequence.prototype.peek = function () {\r\n        return this.nextValue;\r\n    };\r\n    NumberSequence.prototype.skip = function (count) {\r\n        this.nextValue += count;\r\n    };\r\n    return NumberSequence;\r\n}());\r\nexports.NumberSequence = NumberSequence;\r\nexports._ = Utils;\r\nvar PromiseStatus = exports.PromiseStatus = /*@__PURE__*/ (function (PromiseStatus) {\r\n    PromiseStatus[PromiseStatus[\"IN_PROGRESS\"] = 0] = \"IN_PROGRESS\";\r\n    PromiseStatus[PromiseStatus[\"RESOLVED\"] = 1] = \"RESOLVED\";\r\n    return PromiseStatus;\r\n})(exports.PromiseStatus || {});\r\nvar Promise = /*@__PURE__*/ (function () {\r\n    function Promise(callback) {\r\n        this.status = PromiseStatus.IN_PROGRESS;\r\n        this.resolution = null;\r\n        this.listOfWaiters = [];\r\n        callback(this.onDone.bind(this), this.onReject.bind(this));\r\n    }\r\n    Promise.all = function (toCombine) {\r\n        return new Promise(function (resolve) {\r\n            var combinedValues = [];\r\n            var remainingToResolve = toCombine.length;\r\n            toCombine.forEach(function (source, index) {\r\n                source.then(function (sourceResolved) {\r\n                    remainingToResolve--;\r\n                    combinedValues[index] = sourceResolved;\r\n                    if (remainingToResolve == 0) {\r\n                        resolve(combinedValues);\r\n                    }\r\n                });\r\n                combinedValues.push(null);\r\n            });\r\n        });\r\n    };\r\n    Promise.resolve = function (value) {\r\n        return new Promise(function (resolve) { return resolve(value); });\r\n    };\r\n    Promise.external = function () {\r\n        var capture;\r\n        var promise = new Promise(function (resolve) {\r\n            capture = resolve;\r\n        });\r\n        return {\r\n            promise: promise,\r\n            resolve: function (value) {\r\n                capture(value);\r\n            }\r\n        };\r\n    };\r\n    Promise.prototype.then = function (func) {\r\n        if (this.status === PromiseStatus.IN_PROGRESS) {\r\n            this.listOfWaiters.push(func);\r\n        }\r\n        else {\r\n            func(this.resolution);\r\n        }\r\n    };\r\n    Promise.prototype.firstOneOnly = function (func) {\r\n        if (this.status === PromiseStatus.IN_PROGRESS) {\r\n            if (this.listOfWaiters.length === 0) {\r\n                this.listOfWaiters.push(func);\r\n            }\r\n        }\r\n        else {\r\n            func(this.resolution);\r\n        }\r\n    };\r\n    Promise.prototype.map = function (adapter) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.then(function (unmapped) {\r\n                resolve(adapter(unmapped));\r\n            });\r\n        });\r\n    };\r\n    Promise.prototype.resolveNow = function (ifNotResolvedValue, ifResolved) {\r\n        if (this.status == PromiseStatus.IN_PROGRESS)\r\n            return ifNotResolvedValue;\r\n        return ifResolved(this.resolution);\r\n    };\r\n    Promise.prototype.onDone = function (value) {\r\n        this.status = PromiseStatus.RESOLVED;\r\n        this.resolution = value;\r\n        this.listOfWaiters.forEach(function (waiter) { return waiter(value); });\r\n    };\r\n    Promise.prototype.onReject = function (params) {\r\n        console.warn('TBI');\r\n    };\r\n    return Promise;\r\n}());\r\nexports.Promise = Promise;\r\n",null]}