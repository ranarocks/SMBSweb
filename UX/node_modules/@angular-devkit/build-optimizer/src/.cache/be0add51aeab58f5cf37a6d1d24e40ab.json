{"remainingRequest":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\components\\framework\\componentResolver.js","dependencies":[{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\ag-grid\\dist\\lib\\components\\framework\\componentResolver.js","mtime":1525243699601},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530947965468},{"path":"D:\\Imp\\Learn\\SMBSweb\\UX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v17.1.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"../../context/context\");\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\nvar utils_1 = require(\"../../utils\");\nvar componentProvider_1 = require(\"./componentProvider\");\nvar agComponentUtils_1 = require(\"./agComponentUtils\");\nvar componentMetadataProvider_1 = require(\"./componentMetadataProvider\");\nvar ComponentType = exports.ComponentType = /*@__PURE__*/ (function (ComponentType) {\n    ComponentType[ComponentType[\"AG_GRID\"] = 0] = \"AG_GRID\";\n    ComponentType[ComponentType[\"FRAMEWORK\"] = 1] = \"FRAMEWORK\";\n    return ComponentType;\n})(exports.ComponentType || {});\nvar ComponentSource = exports.ComponentSource = /*@__PURE__*/ (function (ComponentSource) {\n    ComponentSource[ComponentSource[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ComponentSource[ComponentSource[\"REGISTERED_BY_NAME\"] = 1] = \"REGISTERED_BY_NAME\";\n    ComponentSource[ComponentSource[\"HARDCODED\"] = 2] = \"HARDCODED\";\n    return ComponentSource;\n})(exports.ComponentSource || {});\nvar ComponentResolver = /*@__PURE__*/ (function () {\n    function ComponentResolver() {\n    }\n    /**\n     * This method returns the underlying representation of the component to be created. ie for Javascript the\n     * underlying function where we should be calling new into. In case of the frameworks, the framework class\n     * object that represents the component to be created.\n     *\n     * This method is handy for different reasons, for example if you want to check if a component has a particular\n     * method implemented without having to create the component, just by inspecting the source component\n     *\n     * It takes\n     *  @param holder: This is the context for which this component needs to be created, it can be gridOptions\n     *      (global) or columnDef mostly.\n     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n     *  @param dynamicComponentParams: Params to be passed to the dynamic component function in case it needs to be\n     *      invoked\n     *  @param defaultComponentName: The name of the component to load if there is no component specified\n     */\n    ComponentResolver.prototype.getComponentToUse = function (holder, propertyName, dynamicComponentParams, defaultComponentName) {\n        /**\n         * There are five things that can happen when resolving a component.\n         *  a) HardcodedFwComponent: That holder[propertyName]Framework has associated a Framework native component\n         *  b) HardcodedJsComponent: That holder[propertyName] has associate a JS component\n         *  c) hardcodedJsFunction: That holder[propertyName] has associate a JS function\n         *  d) hardcodedNameComponent: That holder[propertyName] has associate a string that represents a component to load\n         *  e) That none of the three previous are specified, then we need to use the DefaultRegisteredComponent\n         */\n        var hardcodedNameComponent = null;\n        var HardcodedJsComponent = null;\n        var hardcodedJsFunction = null;\n        var HardcodedFwComponent = null;\n        var dynamicComponentFn;\n        if (holder != null) {\n            var componentPropertyValue = holder[propertyName];\n            if (componentPropertyValue != null) {\n                if (typeof componentPropertyValue === 'string') {\n                    hardcodedNameComponent = componentPropertyValue;\n                }\n                else if (this.agComponentUtils.doesImplementIComponent(componentPropertyValue)) {\n                    HardcodedJsComponent = componentPropertyValue;\n                }\n                else {\n                    hardcodedJsFunction = componentPropertyValue;\n                }\n            }\n            HardcodedFwComponent = holder[propertyName + \"Framework\"];\n            dynamicComponentFn = holder[propertyName + \"Selector\"];\n        }\n        /**\n         * Since we allow many types of flavors for specifying the components, let's make sure this is not an illegal\n         * combination\n         */\n        if ((HardcodedJsComponent && HardcodedFwComponent) ||\n            (hardcodedNameComponent && HardcodedFwComponent) ||\n            (hardcodedJsFunction && HardcodedFwComponent)) {\n            throw Error(\"ag-grid: you are trying to specify: \" + propertyName + \" twice as a component.\");\n        }\n        if (HardcodedFwComponent && !this.frameworkComponentWrapper) {\n            throw Error(\"ag-grid: you are specifying a framework component but you are not using a framework version of ag-grid for : \" + propertyName);\n        }\n        if (dynamicComponentFn && (hardcodedNameComponent || HardcodedJsComponent || hardcodedJsFunction || HardcodedFwComponent)) {\n            throw Error(\"ag-grid: you can't specify both, the selector and the component of ag-grid for : \" + propertyName);\n        }\n        /**\n         * At this stage we are guaranteed to either have,\n         * DEPRECATED\n         * - A unique HardcodedFwComponent\n         * - A unique HardcodedJsComponent\n         * - A unique hardcodedJsFunction\n         * BY NAME- FAVOURED APPROACH\n         * - A unique hardcodedNameComponent\n         * - None of the previous, hence we revert to: RegisteredComponent\n         */\n        if (HardcodedFwComponent) {\n            // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);\n            // console.warn(`${HardcodedFwComponent}`);\n            return {\n                type: ComponentType.FRAMEWORK,\n                component: HardcodedFwComponent,\n                source: ComponentSource.HARDCODED,\n                dynamicParams: null\n            };\n        }\n        if (HardcodedJsComponent) {\n            // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);\n            // console.warn(`${HardcodedJsComponent}`);\n            return {\n                type: ComponentType.AG_GRID,\n                component: HardcodedJsComponent,\n                source: ComponentSource.HARDCODED,\n                dynamicParams: null\n            };\n        }\n        if (hardcodedJsFunction) {\n            // console.warn(`ag-grid: Since version 12.1.0 specifying a function directly is deprecated, you should register the component by name`);\n            // console.warn(`${hardcodedJsFunction}`);\n            return this.agComponentUtils.adaptFunction(propertyName, hardcodedJsFunction, ComponentType.AG_GRID, ComponentSource.HARDCODED);\n        }\n        if (dynamicComponentFn) {\n            var dynamicComponentDef = dynamicComponentFn(dynamicComponentParams);\n            if (dynamicComponentDef != null) {\n                if (dynamicComponentDef.component == null) {\n                    dynamicComponentDef.component = defaultComponentName;\n                }\n                var dynamicComponent = this.resolveByName(propertyName, dynamicComponentDef.component);\n                return utils_1._.assign(dynamicComponent, {\n                    dynamicParams: dynamicComponentDef.params\n                });\n            }\n        }\n        //^^^^^ABOVE DEPRECATED - AT THIS POINT WE ARE RESOLVING BY NAME\n        var componentNameToUse;\n        if (hardcodedNameComponent) {\n            componentNameToUse = hardcodedNameComponent;\n        }\n        else {\n            componentNameToUse = defaultComponentName;\n        }\n        return componentNameToUse == null ? null : this.resolveByName(propertyName, componentNameToUse);\n    };\n    ComponentResolver.prototype.resolveByName = function (propertyName, componentNameOpt) {\n        var componentName = componentNameOpt != null ? componentNameOpt : propertyName;\n        var registeredComponent = this.componentProvider.retrieve(componentName);\n        if (registeredComponent == null)\n            return null;\n        //If it is a FW it has to be registered as a component\n        if (registeredComponent.type == ComponentType.FRAMEWORK) {\n            return {\n                component: registeredComponent.component,\n                type: ComponentType.FRAMEWORK,\n                source: ComponentSource.REGISTERED_BY_NAME,\n                dynamicParams: null\n            };\n        }\n        //If it is JS it may be a function or a component\n        if (this.agComponentUtils.doesImplementIComponent(registeredComponent.component)) {\n            return {\n                component: registeredComponent.component,\n                type: ComponentType.AG_GRID,\n                source: (registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED) ? ComponentSource.REGISTERED_BY_NAME : ComponentSource.DEFAULT,\n                dynamicParams: null\n            };\n        }\n        // This is a function\n        return this.agComponentUtils.adaptFunction(propertyName, registeredComponent.component, registeredComponent.type, (registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED) ? ComponentSource.REGISTERED_BY_NAME : ComponentSource.DEFAULT);\n    };\n    /**\n     * Useful to check what would be the resultant params for a given object\n     *  @param holder: This is the context for which this component needs to be created, it can be gridOptions\n     *      (global) or columnDef mostly.\n     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n     *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n     *      specified by the user in the configuration\n     * @returns {any} It merges the user agGridParams with the actual params specified by the user.\n     */\n    ComponentResolver.prototype.mergeParams = function (holder, propertyName, agGridParams, dynamicCustomParams, dynamicParams) {\n        if (dynamicParams === void 0) {\n            dynamicParams = null;\n        }\n        var customParamsRaw = holder ? holder[propertyName + \"Params\"] : null;\n        var finalParams = {};\n        utils_1._.mergeDeep(finalParams, agGridParams);\n        if (customParamsRaw != null) {\n            var customParams = null;\n            if (typeof customParamsRaw === 'function') {\n                customParams = customParamsRaw(dynamicCustomParams);\n            }\n            else {\n                customParams = customParamsRaw;\n            }\n            utils_1._.mergeDeep(finalParams, customParams);\n        }\n        utils_1._.mergeDeep(finalParams, dynamicParams);\n        if (!finalParams.api) {\n            finalParams.api = this.gridOptions.api;\n        }\n        return finalParams;\n    };\n    /**\n     * This method creates a component given everything needed to guess what sort of component needs to be instantiated\n     * It takes\n     *  @param holderOpt: This is the context for which this component needs to be created, it can be gridOptions\n     *      (global) or columnDef mostly.\n     *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n     *      specified by the user in the configuration\n     *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n     *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n     *  @param dynamicComponentParams: Params to be passed to the dynamic component function in case it needs to be\n     *      invoked\n     *  @param defaultComponentName: The actual name of the component to instantiate, this is usually the same as propertyName, but in\n     *      some cases is not, like floatingFilter, if it is the same is not necessary to specify\n     *  @param mandatory: Handy method to tell if this should return a component ALWAYS. if that is the case, but there is no\n     *      component found, it throws an error, by default all components are MANDATORY\n     *  @param customInitParamsCb: A chance to customise the params passed to the init method. It receives what the current\n     *  params are and the component that init is about to get called for\n     */\n    ComponentResolver.prototype.createAgGridComponent = function (holderOpt, agGridParams, propertyName, dynamicComponentParams, defaultComponentName, mandatory, customInitParamsCb) {\n        if (mandatory === void 0) {\n            mandatory = true;\n        }\n        var holder = holderOpt == null ? this.gridOptions : holderOpt;\n        //Create the component instance\n        var componentAndParams = this.newAgGridComponent(holder, propertyName, dynamicComponentParams, defaultComponentName, mandatory);\n        if (!componentAndParams)\n            return null;\n        // Wire the component and call the init method with the correct params\n        var finalParams = this.mergeParams(holder, propertyName, agGridParams, dynamicComponentParams, componentAndParams[1]);\n        // a temporary fix for AG-1574\n        // AG-1715 raised to do a wider ranging refactor to improve this\n        finalParams.agGridReact = this.context.getBean('agGridReact') ? utils_1._.cloneObject(this.context.getBean('agGridReact')) : {};\n        // AG-1716 - directly related to AG-1574 and AG-1715\n        finalParams.frameworkComponentWrapper = this.context.getBean('frameworkComponentWrapper') ? this.context.getBean('frameworkComponentWrapper') : {};\n        var deferredInit = this.initialiseComponent(componentAndParams[0], finalParams, customInitParamsCb);\n        if (deferredInit == null) {\n            return utils_1.Promise.resolve(componentAndParams[0]);\n        }\n        else {\n            var asPromise = deferredInit;\n            return asPromise.map(function (notRelevant) { return componentAndParams[0]; });\n        }\n    };\n    /**\n     * This method creates a component given everything needed to guess what sort of component needs to be instantiated\n     * It takes\n     *  @param clazz: The class to instantiate,\n     *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n     *      specified by the user in the configuration\n     *  @param customInitParamsCb: A chance to customise the params passed to the init method. It receives what the current\n     *  params are and the component that init is about to get called for\n     */\n    ComponentResolver.prototype.createInternalAgGridComponent = function (clazz, agGridParams, customInitParamsCb) {\n        var internalComponent = new clazz();\n        this.initialiseComponent(internalComponent, agGridParams, customInitParamsCb);\n        return internalComponent;\n    };\n    ComponentResolver.prototype.newAgGridComponent = function (holder, propertyName, dynamicComponentParams, defaultComponentName, mandatory) {\n        if (mandatory === void 0) {\n            mandatory = true;\n        }\n        var componentToUse = this.getComponentToUse(holder, propertyName, dynamicComponentParams, defaultComponentName);\n        if (!componentToUse || !componentToUse.component) {\n            if (mandatory) {\n                console.error(\"Error creating component \" + propertyName + \"=>\" + defaultComponentName);\n            }\n            return null;\n        }\n        if (componentToUse.type === ComponentType.AG_GRID) {\n            return [\n                new componentToUse.component(),\n                componentToUse.dynamicParams\n            ];\n        }\n        //Using framework component\n        var FrameworkComponentRaw = componentToUse.component;\n        var thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);\n        return [\n            this.frameworkComponentWrapper.wrap(FrameworkComponentRaw, thisComponentConfig.mandatoryMethodList, thisComponentConfig.optionalMethodList, defaultComponentName),\n            componentToUse.dynamicParams\n        ];\n    };\n    ComponentResolver.prototype.initialiseComponent = function (component, agGridParams, customInitParamsCb) {\n        this.context.wireBean(component);\n        if (customInitParamsCb == null) {\n            return component.init(agGridParams);\n        }\n        else {\n            return component.init(customInitParamsCb(agGridParams, component));\n        }\n    };\n    __decorate([\n        context_1.Autowired(\"gridOptions\"),\n        __metadata(\"design:type\", Object)\n    ], ComponentResolver.prototype, \"gridOptions\", void 0);\n    __decorate([\n        context_1.Autowired(\"gridOptionsWrapper\"),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], ComponentResolver.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired(\"context\"),\n        __metadata(\"design:type\", context_1.Context)\n    ], ComponentResolver.prototype, \"context\", void 0);\n    __decorate([\n        context_1.Autowired(\"agComponentUtils\"),\n        __metadata(\"design:type\", agComponentUtils_1.AgComponentUtils)\n    ], ComponentResolver.prototype, \"agComponentUtils\", void 0);\n    __decorate([\n        context_1.Autowired(\"componentMetadataProvider\"),\n        __metadata(\"design:type\", componentMetadataProvider_1.ComponentMetadataProvider)\n    ], ComponentResolver.prototype, \"componentMetadataProvider\", void 0);\n    __decorate([\n        context_1.Autowired(\"componentProvider\"),\n        __metadata(\"design:type\", componentProvider_1.ComponentProvider)\n    ], ComponentResolver.prototype, \"componentProvider\", void 0);\n    __decorate([\n        context_1.Optional(\"frameworkComponentWrapper\"),\n        __metadata(\"design:type\", Object)\n    ], ComponentResolver.prototype, \"frameworkComponentWrapper\", void 0);\n    ComponentResolver = __decorate([\n        context_1.Bean('componentResolver')\n    ], ComponentResolver);\n    return ComponentResolver;\n}());\nexports.ComponentResolver = ComponentResolver;\n",null]}